// VoxelizationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

// Voxel grid buffer (UAV)
RWStructuredBuffer<uint> VoxelGridBuffer;
RWStructuredBuffer<float3> GridVelocityBuffer;

// Mesh data buffer (SRV)
Buffer<float> TriangleVerts;
Buffer<uint> TriangleIndices;
StructuredBuffer<float3> VertexVelocitiesWorldSpace;

// Voxel grid parameters
float3 GridMin;
int3 GridDim;

// Mesh data parameters
float4x4 LocalToWorld;
uint TriangleCount;
uint VertexCount;
uint IndexCount;


//////////////////////////////////////////////////////////////////////////
// Helper Functions
void LoadVertexPosition(in uint vertex, out float3 pos)
{
    vertex = clamp(vertex, 0, VertexCount - 1);
    pos.x = TriangleVerts[vertex * 3 + 0];
    pos.y = TriangleVerts[vertex * 3 + 1];
    pos.z = TriangleVerts[vertex * 3 + 2];
}

void LoadVertexVelocity(in uint vertex, out float3 velocity)
{
    vertex = clamp(vertex, 0, VertexCount - 1);
    velocity = VertexVelocitiesWorldSpace[vertex];
}

void LoadTriangle(in uint triangleIdx, 
    out float3 v0, out float3 v1, out float3 v2, 
    out float3 velocity0, out float3 velocity1, out float3 velocity2)
{
    uint i0 = clamp(TriangleIndices[triangleIdx * 3 + 0], 0, VertexCount - 1);
    uint i1 = clamp(TriangleIndices[triangleIdx * 3 + 1], 0, VertexCount - 1);
    uint i2 = clamp(TriangleIndices[triangleIdx * 3 + 2], 0, VertexCount - 1);

    LoadVertexPosition(i0, v0);
    LoadVertexPosition(i1, v1);
    LoadVertexPosition(i2, v2);
    LoadVertexVelocity(i0, velocity0);
    LoadVertexVelocity(i1, velocity1);
    LoadVertexVelocity(i2, velocity2);
}

void WriteOutput(float4 pos, float3 velocity)
{
    if (pos.x < 0 || pos.y < 0 || pos.z < 0 ||
        pos.x >= GridDim.x || pos.y >= GridDim.y || pos.z >= GridDim.z)
    {
        return;
    }

    uint idx = floor(pos.x) + floor(pos.y) * GridDim.x + floor(pos.z) * GridDim.x * GridDim.y;
    VoxelGridBuffer[idx] = 1;
    GridVelocityBuffer[idx] = velocity;
}

void WriteOutput(float3 pos, float3 velocity)
{
    if (pos.x < 0 || pos.y < 0 || pos.z < 0 ||
        pos.x >= GridDim.x || pos.y >= GridDim.y || pos.z >= GridDim.z)
    {
        return;
    }

    uint idx = floor(pos.x) + floor(pos.y) * GridDim.x + floor(pos.z) * GridDim.x * GridDim.y;
    VoxelGridBuffer[idx] = 1;
    GridVelocityBuffer[idx] = velocity;
}


float3 GetBarycentricCoordinates(in float4 p, in float4 v0, in float4 v1, in float4 v2, in float4 normal)
{
    // TODO: optimize with precomputed e1 and e2
    
    // Project p onto the plane
    float4 pProj = p - dot(p - v0, normal) * normal;
    
    // Compute edge vectors from v0
    float3 e1 = (v1 - v0).xyz;
    float3 e2 = (v2 - v0).xyz;
    float3 d = (pProj - v0).xyz;
    
    // Compute dot products
    float dot00 = dot(e1, e1);
    float dot01 = dot(e1, e2);
    float dot02 = dot(e1, d);
    float dot11 = dot(e2, e2);
    float dot12 = dot(e2, d);
    
    // Compute denominator
    float denom = dot00 * dot11 - dot01 * dot01;
    
    // Avoid division by zero
    if (abs(denom) < 1e-6)
    {
        return float3(0, 0, 0);
    }
    
    // Compute barycentric coordinates u and v
    float invDenom = 1.0 / denom;
    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    float w = 1.0 - u - v;
    
    return float3(u, v, w);
}


//////////////////////////////////////////////////////////////////////////
// Algorithm Helper Functions
void swap(inout float4 v0, inout float4 v1)
{
    float4 tmp = v0;
    v0 = v1;
    v1 = tmp;
}

void SortVertices(inout float4 v0, inout float4 v1, inout float4 v2, in float4 pAxis)
{
	// TODO: optimize branching and calculation
    if (dot(v0, pAxis) < dot(v1, pAxis))
    {
        swap(v0, v1);
    }
    if (dot(v1, pAxis) < dot(v2, pAxis))
    {
        swap(v1, v2);
    }
    if (dot(v0, pAxis) < dot(v1, pAxis))
    {
        swap(v0, v1);
    }
}

float4 PointInEdge(in float4 vA, in float4 vB, in float h, in float4 pAxis)
{
    // Compute projection values
    float a = dot(vA, pAxis);
    float b = dot(vB, pAxis);

    // If the edge does not cross this height, return vA (no-op)
    // But the caller should handle empty intersections.
    float denom = (b - a);
    if (abs(denom) < 1e-6)
    {
        return vA;  // Edge is parallel to scanline
    }

    // Solve for interpolation factor t where:
    // dot(lerp(vA, vB, t), pAxis) = h
    float t = (h - a) / denom;
    t = saturate(t); // clamp for safety

    // Linear interpolation on full float4
    return lerp(vA, vB, t);
}

float4 CalcFlatAdvance(in float4 pAxis, in float4 normal)
{
	// normal and pAxis have length 1.0f
    const float4 project = pAxis - normal * dot(normal, pAxis);

    return sign(project * (float4(1.f, 1.f, 1.f, 1.f) - pAxis));
}

float4 CalcPrimaryAxis(float4 v0, float4 v1, float4 v2)
{
    // TODO: optimize branching

    float4 maxV = max(v0, max(v1, v2));
    float4 minV = min(v0, min(v1, v2));

    float4 diff = pow(maxV - minV, 2);

    if (diff.x >= diff.y && diff.x >= diff.z)
    {
        return float4(1.f, 0.f, 0.f, 0.f);
    }
    else if (diff.y >= diff.z)
    {
        return float4(0.f, 1.f, 0.f, 0.f);
    }
    else
    {
        return float4(0.f, 0.f, 1.f, 0.f);
    }
}


//////////////////////////////////////////////////////////////////////////
// Algorithm Core Functions
void Scanline(float4 start, float4 end, float4 flatAdvance, float4 normal, float4 pAxis, 
    float4 v0, float4 v1, float4 v2, 
    float3 velocity0, float3 velocity1, float3 velocity2)
{
    float4 d = end - start;
    float4 step = sign(d);    // voxel traversing step direction
    float4 deltaT = 1 / max(abs(d), 0.00001);
    float4 tMax = deltaT * select(step > 0,  ceil(start) - start, start - floor(start));

    int steps = int(dot(floor(end) - floor(start), step)); // number of voxels to traverse
    float4 currentVoxel = start;
    while (/*steps >= 0*/ tMax.x < 1 || tMax.y < 1 || tMax.z < 1)
    {        
        float3 barycentric = GetBarycentricCoordinates(currentVoxel, v0, v1, v2, normal);
        float3 velocity = barycentric.x * velocity0 + barycentric.y * velocity1 + barycentric.z * velocity2;
        WriteOutput(currentVoxel, velocity);

        if (tMax.x < tMax.y && tMax.x < tMax.z)
        {
            currentVoxel.x += step.x;
            tMax.x += deltaT.x;
        }
        else if (tMax.y < tMax.z)
        {
            currentVoxel.y += step.y;
            tMax.y += deltaT.y;
        }
        else
        {
            currentVoxel.z += step.z;
            tMax.z += deltaT.z;
        }
        steps--;
    }
}

void VoxelizeTriangle(float4 v0, float4 v1, float4 v2, float4 normal, float3 velocity0, float3 velocity1, float3 velocity2)
{
	// Step 1 - Initialization
    float4 pAxis = CalcPrimaryAxis(v0, v1, v2);

    SortVertices( v0, v1, v2, pAxis);
    float4 flatAdvance = CalcFlatAdvance(pAxis, normal);

	// Step 2 - Interior Traversal stating from v2’s height along the primary axis
    int h = int(dot(v2, pAxis));

	// Bottom half, up to v1’s height
    while (h <= int(dot(v1, pAxis)))
    {
        float4 start = PointInEdge(v2, v0, h, pAxis);
        float4 end = PointInEdge(v2, v1, h, pAxis);
        Scanline(start, end, flatAdvance, normal, pAxis, v0, v1, v2, velocity0, velocity1, velocity2);
        h = h + 1;
    }

	// Top Half, up to v0’s height
    while (h <= int(dot(v0, pAxis)))
    {
        float4 start = PointInEdge(v2, v0, h, pAxis);
        float4 end = PointInEdge(v1, v0, h, pAxis);
        Scanline(start, end, flatAdvance, normal, pAxis, v0, v1, v2, velocity0, velocity1, velocity2);
        h = h + 1;
    }

	// Step 3 - Edge Voxelization
    Scanline(v0, v1, flatAdvance, normal, pAxis, v0, v1, v2, velocity0, velocity1, velocity2);
    Scanline(v1, v2, flatAdvance, normal, pAxis, v0, v1, v2, velocity0, velocity1, velocity2);
	Scanline(v2, v0, flatAdvance, normal, pAxis, v0, v1, v2, velocity0, velocity1, velocity2);
}

#define DEBUG 0

[numthreads(32, 1, 1)]
void VoxelizeMesh(uint DTid : SV_DispatchThreadID)
{
    if (DTid >= TriangleCount)
    {
        return;
    }

    float3 vertices[3];
    float3 velocities[3];
    LoadTriangle(DTid, vertices[0], vertices[1], vertices[2], velocities[0], velocities[1], velocities[2]);

    float4 v0 = float4(vertices[0], 1.0f);
    float4 v1 = float4(vertices[1], 1.0f);
    float4 v2 = float4(vertices[2], 1.0f);

    v0 = mul(LocalToWorld, v0);
    v1 = mul(LocalToWorld, v1);
    v2 = mul(LocalToWorld, v2);

    v0.xyz -= GridMin;
    v1.xyz -= GridMin;
    v2.xyz -= GridMin;

    // Adjusted for UE's left hand coordinate system, 
    float4 normal = -float4(normalize(cross(v1.xyz - v0.xyz, v2.xyz - v0.xyz)), 0); 

#if DEBUG
   
#else
	VoxelizeTriangle(v0, v1, v2, normal, velocities[0], velocities[1], velocities[2]);
#endif
    
}