// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

float Scale;
float Translate;

RWStructuredBuffer<float> InputBuffer;
RWStructuredBuffer<float> OutputBuffer;
RWTexture2DArray<float4> SimulationDataArray;
RWTexture2DArray<float4> SimulationDataArray2;
RWTexture2D<float4> DebugTexture;

///////////////
//
// Lattice Types:
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////

void StoreSimulationData2D(in uint texelX, in uint texelY, in float f[9], in float boundary)
{
    SimulationDataArray[uint3(texelX, texelY, 0)] = float4(f[0], f[1], f[2], f[3]);
    SimulationDataArray[uint3(texelX, texelY, 1)] = float4(f[4], f[5], f[6], f[7]);
    SimulationDataArray[uint3(texelX, texelY, 2)] = float4(f[8], boundary, 0., 0.);
}

void StoreSimulationData2D_2(in uint texelX, in uint texelY, in float f[9], in float boundary)
{
    SimulationDataArray2[uint3(texelX, texelY, 0)] = float4(f[0], f[1], f[2], f[3]);
    SimulationDataArray2[uint3(texelX, texelY, 1)] = float4(f[4], f[5], f[6], f[7]);
    SimulationDataArray2[uint3(texelX, texelY, 2)] = float4(f[8], boundary, 0., 0.);
}

void ReadSimulationData2D(in uint texelX, in uint texelY, out float f[9], out float boundary)
{
    float4 f0_3 = SimulationDataArray[uint3(texelX, texelY, 0)];
    float4 f4_7 = SimulationDataArray[uint3(texelX, texelY, 1)];
    float4 f8_ = SimulationDataArray[uint3(texelX, texelY, 2)];
    f[0] = f0_3.x;
    f[1] = f0_3.y;
    f[2] = f0_3.z;
    f[3] = f0_3.w;
    f[4] = f4_7.x;
    f[5] = f4_7.y;
    f[6] = f4_7.z;
    f[7] = f4_7.w;
    f[8] = f8_.x;
    boundary = f8_.y;
}

void ReadBoundaryValues2D(in uint texelX, in uint texelY, out float2 u, out float p)
{
    u = SimulationDataArray[uint3(texelX, texelY, 3)].xy;
    p = SimulationDataArray[uint3(texelX, texelY, 3)].z;
}

void StoreBoundaryValues2D(in uint texelX, in uint texelY, in float2 u, in float p)
{
    SimulationDataArray[uint3(texelX, texelY, 3)].xy = u;
    SimulationDataArray[uint3(texelX, texelY, 3)].z = p;
}

void ReadSimulationDataPreStream2D(in uint texelX, in uint texelY, out float f[9])
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    f[0] = SimulationDataArray[uint3(texelX, texelY, 0)].x;
    f[1] = SimulationDataArray[uint3(texelX + 1, texelY + 1, 0)].y;
    f[2] = SimulationDataArray[uint3(texelX, texelY + 1, 0)].z;
    f[3] = SimulationDataArray[uint3(texelX - 1, texelY + 1, 0)].w;
    f[4] = SimulationDataArray[uint3(texelX + 1, texelY, 1)].x;
    f[5] = SimulationDataArray[uint3(texelX - 1, texelY, 1)].y;
    f[6] = SimulationDataArray[uint3(texelX + 1, texelY - 1, 1)].z;
    f[7] = SimulationDataArray[uint3(texelX, texelY - 1, 1)].w;
    f[8] = SimulationDataArray[uint3(texelX - 1, texelY - 1, 2)].x;
}

void ReadSimulationData2D_2(in uint texelX, in uint texelY, out float f[9], out float boundary)
{
    float4 f0_3 = SimulationDataArray2[uint3(texelX, texelY, 0)];
    float4 f4_7 = SimulationDataArray2[uint3(texelX, texelY, 1)];
    float4 f8_ = SimulationDataArray2[uint3(texelX, texelY, 2)];
    f[0] = f0_3.x;
    f[1] = f0_3.y;
    f[2] = f0_3.z;
    f[3] = f0_3.w;
    f[4] = f4_7.x;
    f[5] = f4_7.y;
    f[6] = f4_7.z;
    f[7] = f4_7.w;
    f[8] = f8_.x;
    boundary = f8_.y;
}

float sphere(float2 p, float2 center, float radius)
{
    return length(p - center) - radius;
}

[numthreads(16, 16, 1)]
void FunctionMultiply(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID: SV_GroupID)
{
    OutputBuffer[tid.x] = InputBuffer[tid.x] * Scale + Translate;
    uint texelX = GroupID.x * 16 + tid.x;
    uint texelY = GroupID.y * 16 + tid.y;
    SimulationDataArray[uint3(texelX, texelY, 0)].x = (float) tid.x / 16.;
    SimulationDataArray[uint3(texelX, texelY, 0)].y = (float) tid.y / 16.;
}

float2 GetBoundaryVelocity(uint texelX, uint texelY)
{
    float maxU = 0.05;
    return maxU;
    //return float2(0., maxU * (-pow(texelY - 128., 2.) / 128. / 128. + 1.));
}


[numthreads(16, 16, 1)]
void LBM_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    // lbm constants
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0., 0.);
    float p = 0.03;
    float feq[9];
    
    float boundary = 0.;
    
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <=0 || texelY >= 255)
    {
        boundary = 1.; // type 1 lattice
        /*
    
        1 2 3 
        4 0 5
        6 7 8
    
        */
        feq[0] = -1.; // pos 0 does not matter, will be overwriten later
        // below is a generalize of out boundary in x and y
        feq[1] = -0.7071;
        feq[2] = -0.5;
        feq[3] = -0.7071;
        feq[4] = -0.5;
        feq[5] = -0.5;
        feq[6] = -0.7071;
        feq[7] = -0.5;
        feq[8] = -0.7071;
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 10;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 1.;
        for (int i = 0; i < 9; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2.; // type 2 lattice with fixed velocity
        u = GetBoundaryVelocity(texelX, texelY);
        p = 0.1;
        StoreBoundaryValues2D(texelX, texelY, u, p);

    }
    if (texelX == 255 && texelY > 0 &&  texelY < 255)
    {
        boundary = 3.;
    }
    /*if (texelX == 254)
    {
        boundary = 3.; // type 3 lattice with fixed velocity
        //p = 0.;
        StoreBoundaryValues2D(texelX, texelY, u, p);
    }*/
    
    if (boundary == 0. || boundary == 2. || boundary == 3.)
    {
        for (int i = 0; i < 9; i++)
        {
            feq[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    
    StoreSimulationData2D(texelX, texelY, feq, boundary);
    
    DebugTexture[uint2(texelX, texelY)].x = (float) texelX / 256.;
    DebugTexture[uint2(texelX, texelY)].y = length(u);
    DebugTexture[uint2(texelX, texelY)].z = p;
}

[numthreads(16, 16, 1)]
void LBM_Streaming(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    float f[9];
    float f_streamed[9];
    float boundary;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    
    if (boundary >= 1.) // no simulation inside solid 
    {
        return;
    }
    ReadSimulationDataPreStream2D(texelX, texelY, f_streamed);
    StoreSimulationData2D_2(texelX, texelY, f_streamed, boundary);
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[9], out float2 u, out float p)
{
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    p = 0.;
    u = float2(0., 0.);
    for (int i = 0; i < 9; i++)
    {
        p += f[i];
        u += c[i] * f[i];
    }
    u = u / p;
}

float GetEquilibrium(float2 u, float p, float2 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}

[numthreads(16, 16, 1)]
void LBM_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    // lbm distribution functions
    float f[9];
    float f_streamed[9];
    float boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    if (boundary == 3.)
    {
        float f_left[9];
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY, f_left, boundary_left);
        StoreSimulationData2D(texelX, texelY, f_left, boundary);
    }
    if (boundary>=1.) // no simulation inside solid 
    {
        DebugTexture[uint2(texelX, texelY)] = float4(1., 0., 1., 1.);
        return;
    }
    ReadSimulationData2D_2(texelX, texelY, f_streamed, boundary);
    
    
    float p = 0.;
    float2 u = float2(0., 0.);
    
    // boundary treatment
    // bounce back
    for (int i = 0; i < 9; i++)
    {
        if (f_streamed[i] < 0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            float q = 1. + f_streamed[i] / length(c[i]);
            float p_b_prev = 0.;
            float2 u_b_prev = 0.;
            GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float2(0.0, 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
                + q / (1. + q) * f[9 - i].x;
            f_streamed[i] = f_b;
            
            // classical bounce-back
            // f_streamed[i] = f_streamed[9 - i];
        }
    }
    GetVelocityAndDensity(f_streamed, u, p);
    DebugTexture[uint2(texelX, texelY)].x = length(u);
    DebugTexture[uint2(texelX, texelY)].z = p;
    if (IsNaN(p) || IsNaN(length(u)))
    {
        DebugTexture[uint2(texelX, texelY)].y = 0.5;
    }
    
    // collision
    float cs = 1. / sqrt(3.);
    float feq[9];
    for (int i = 0; i < 9; i++)
    {
        feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        f[i] = f_streamed[i] - (f_streamed[i] - feq[i]) / 0.8; // relaxation time tau = 0.1
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}