// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

float Scale;
float Translate;

RWStructuredBuffer<float> InputBuffer;
RWStructuredBuffer<float> OutputBuffer;
RWTexture2DArray<float4> SimulationDataArray;
RWTexture2D<float4> DebugTexture;
RWStructuredBuffer<int> DebugBuffer;

///////////////
//
// Lattice Types:
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////

void StoreSimulationData2D(in uint texelX, in uint texelY, in float f[9], in int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        DebugBuffer[i + 10 * texelX + 10 * 256 * texelY] = asint(f[i]);
    }
    DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY] = boundary;
}

void StoreSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + 10 * texelX + 10 * 256 * texelY], asint(f_i), _);
}

void ReadSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + 10 * texelX + 10 * 256 * texelY]);
}

void ReadSimulationData2D(in uint texelX, in uint texelY, out float f[9], out int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        f[i] = asfloat(DebugBuffer[i + 10 * texelX + 10 * 256 * texelY]);
    }
    boundary = DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY];
}

float sphere(float2 p, float2 center, float radius)
{
    return length(p - center) - radius;
}

[numthreads(16, 16, 1)]
void FunctionMultiply(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID: SV_GroupID)
{
    OutputBuffer[tid.x] = InputBuffer[tid.x] * Scale + Translate;
    uint texelX = GroupID.x * 16 + tid.x;
    uint texelY = GroupID.y * 16 + tid.y;
    SimulationDataArray[uint3(texelX, texelY, 0)].x = (float) tid.x / 16.;
    SimulationDataArray[uint3(texelX, texelY, 0)].y = (float) tid.y / 16.;
}

float2 GetBoundaryVelocity(uint texelX, uint texelY)
{
    float maxU = 0.05;
    return maxU;
}


[numthreads(16, 16, 1)]
void LBM_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    // lbm constants
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0.001, 0.);
    float p = 0.03;
    float feq[9];
    
    int boundary = 0;
    float f_fake = -1. * (texelX + 256 * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <=0 || texelY >= 255)
    {
        boundary = 1; // type 1 lattice
        /*
    
        1 2 3 
        4 0 5
        6 7 8
    
        */
        feq[0] = f_fake; // pos 0 does not matter, will be overwriten later
        // below is a generalize of out boundary in x and y
        feq[1] = f_fake;
        feq[2] = f_fake;
        feq[3] = f_fake;
        feq[4] = f_fake;
        feq[5] = f_fake;
        feq[6] = f_fake;
        feq[7] = f_fake;
        feq[8] = f_fake;
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 10;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 1;
        for (int i = 0; i < 9; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float2(0.0, 0.05);
        p = 0.06;

    }
    if (texelX == 255 && texelY > 0 &&  texelY < 255)
    {
        boundary = 3;
    }
    
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < 9; i++)
        {
            feq[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    
    StoreSimulationData2D(texelX, texelY, feq, boundary);
    
    DebugTexture[uint2(texelX, texelY)].x = 0.;
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = 0.;
}

[numthreads(16, 16, 1)]
void LBM_Streaming(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    int texelX = (int)DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    int2 c[9] =
    {
        int2(0, 0),
        int2(-1, -1),
        int2(0, -1),
        int2(1, -1),
        int2(-1, 0),
        int2(1, 0),
        int2(-1, 1),
        int2(0, 1),
        int2(1, 1),
    };
    for (int i = 5; i < 9; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        ReadSimulationDataIndex2D(texelX, texelY, 9-i, f_1);
        ReadSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_2);
        StoreSimulationDataIndex2D(texelX, texelY, 9-i, f_2);
        StoreSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_1);
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[9], out float2 u, out float p)
{
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    p = 0.;
    u = float2(0., 0.);
    for (int i = 0; i < 9; i++)
    {
        p += f[i];
        u += c[i] * f[i];
    }
    u = u / p;
}

float GetEquilibrium(float2 u, float p, float2 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}

[numthreads(16, 16, 1)]
void LBM_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    // lbm distribution functions
    float f[9];
    int boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    float f_fake = -1. * (texelX + 256 * texelY);
    if (boundary == 1)
    {
        f[0] = f_fake;
        f[1] = f_fake;
        f[2] = f_fake;
        f[3] = f_fake;
        f[4] = f_fake;
        f[5] = f_fake;
        f[6] = f_fake;
        f[7] = f_fake;
        f[8] = f_fake;
    }
    if (boundary == 2)
    {
        float2 u = float2(0.5, 0.);
        float p = 0.06;
        u = float2(0.0, 0.05);
        p = 0.06;
        for (int i = 0; i < 9; i++)
        {
            f[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    if (boundary == 3 && texelY==1)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY + 1, f, boundary_left);
    }
    else if (boundary == 3 && texelY == 254)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY - 1, f, boundary_left);
    }
    else if (boundary == 3)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY, f, boundary_left);
    }
    if (boundary>=1) // no simulation inside solid 
    {
        DebugTexture[uint2(texelX, texelY)] = float4(1., 1., 1., 1.);
        for (int i = 1; i < 5; i++)
        {
            float temp = f[i];
            f[i] = f[9 - i];
            f[9 - i] = temp;
        }
        StoreSimulationData2D(texelX, texelY, f, boundary);
        return;
    }
    //ReadSimulationData2D_2(texelX, texelY, f_streamed, boundary);
    
    
    float p = 0.;
    float2 u = float2(0., 0.);
    
    // boundary treatment
    // bounce back
    for (int i = 1; i < 9; i++)
    {
        if (f[i] < 0. && f[9-i]<0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            /*float q = 1. + f_streamed[i] / length(c[i]);
            float p_b_prev = 0.;
            float2 u_b_prev = 0.;
            GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float2(0.0, 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
                + q / (1. + q) * f[9 - i].x;
            f_streamed[i] = f_b;
            */
            // classical bounce-back
            f[i] = 0.;
            f[9 - i] = 0.;
            DebugTexture[uint2(texelX, texelY)].xyz = float3(0.,1.,0.);
        }
        else if(f[i]<0.)
        {
            f[i] = f[9 - i];
            DebugTexture[uint2(texelX, texelY)].xyz = float3(1., 0., 0.);
        }
    }
    GetVelocityAndDensity(f, u, p);
    DebugTexture[uint2(texelX, texelY)].xyz = float3(length(u), 0., p);
    if (IsNaN(p) || IsNaN(length(u)) || p == 0. || length(u)==0.)
    {
        DebugTexture[uint2(texelX, texelY)].xyz = float3(1.,1.,1.);
    }
    
    // collision
    float cs = 1. / sqrt(3.);
    float feq[9];
    for (int i = 0; i < 9; i++)
    {
        feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        f[i] = f[i] - (f[i] - feq[i]) / 0.8;
    }
    for (int i = 1; i < 5; i++)
    {
        float temp = f[i];
        f[i] = f[9 - i];
        f[9 - i] = temp;
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}