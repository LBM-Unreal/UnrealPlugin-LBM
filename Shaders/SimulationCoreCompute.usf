// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

float Scale;
float Translate;

RWTexture2D<float4> DebugTexture;
RWStructuredBuffer<int> DebugBuffer;

///////////////
//
// Lattice Types:
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////

#define ELEMENT_DIM 14

float3 hsv2rgb(float3 c)
{
    float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * lerp(K.xxx, saturate(p - K.xxx), c.y);
}

float3 ColorByValue(float val)
{
    return hsv2rgb(float3(val, 1., 1.));
}

void StoreSimulationData2D(in uint texelX, in uint texelY, in float f[9], in int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        DebugBuffer[i + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = asint(f[i]);
    }
    DebugBuffer[9 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = boundary;
}

void StoreSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY], asint(f_i), _);
}

void ReadSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
}

void ReadSimulationData2D(in uint texelX, in uint texelY, out float f[9], out int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        f[i] = asfloat(DebugBuffer[i + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
    }
    boundary = DebugBuffer[9 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY];
}

struct SurfaceProperty
{
    float phi;
    float m;
    float m_ex;
    bool flg_fluid;
    bool flg_interface;
    bool flg_gas;
    bool flg_solid;
    bool flg_i_to_g;
    bool flg_i_to_f;
};
void ReadSurfaceProperty(in uint texelX, in uint texelY, out SurfaceProperty OutProperty) // see Lehmann2019 chapter 6
{
    OutProperty.phi = asfloat(DebugBuffer[10 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
    OutProperty.m = asfloat(DebugBuffer[11 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
    OutProperty.m_ex = asfloat(DebugBuffer[12 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
    uint flags = uint(DebugBuffer[13 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY]);
    OutProperty.flg_fluid = flags & (1 << 2);
    OutProperty.flg_interface = flags & (1 << 1);
    OutProperty.flg_gas = flags & (1 << 0);
    OutProperty.flg_solid = flags & (1 << 3);
    OutProperty.flg_i_to_g = flags & (1 << 4);
    OutProperty.flg_i_to_f = flags & (1 << 5);
}

void StoreSurfaceProperty(in uint texelX, in uint texelY, in SurfaceProperty InProperty)
{
    DebugBuffer[10 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = asint(InProperty.phi);
    DebugBuffer[11 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = asint(InProperty.m);
    DebugBuffer[12 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = asint(InProperty.m_ex);
    uint flags = 0u;
    flags = flags | (uint(InProperty.flg_fluid) << 2);
    flags = flags | (uint(InProperty.flg_interface) << 1);
    flags = flags | (uint(InProperty.flg_gas) << 0);
    flags = flags | (uint(InProperty.flg_solid) << 3);
    flags = flags | (uint(InProperty.flg_i_to_g) << 4);
    flags = flags | (uint(InProperty.flg_i_to_f) << 5);
    DebugBuffer[13 + ELEMENT_DIM * texelX + ELEMENT_DIM * 256 * texelY] = flags;
}

float sphere(float2 p, float2 center, float radius)
{
    return length(p - center) - radius;
}

[numthreads(16, 16, 1)]
void FunctionMultiply(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID: SV_GroupID)
{
    uint texelX = GroupID.x * 16 + tid.x;
    uint texelY = GroupID.y * 16 + tid.y;
}

float2 GetBoundaryVelocity(uint texelX, uint texelY)
{
    float maxU = 0.05;
    return maxU;
}

void DisplaySurfaceProp(uint texelX, uint texelY, SurfaceProperty surfaceProp)
{
    float4 debugValue = float4(0., 0., 0., 1.);
    if (surfaceProp.flg_fluid)
    {
        debugValue = float4(0., 0., 1., 1.);
    }
    else if (surfaceProp.flg_interface)
    {
        debugValue = float4(0., 1., 0., 1.);
    }
    else if (surfaceProp.flg_gas)
    {
        debugValue = float4(1., 0., 0., 1.);
    }
    else if (surfaceProp.flg_solid)
    {
        debugValue = float4(1., 1., 1., 1.);
    }
    DebugTexture[uint2(texelX, texelY)] = debugValue;
}

void DisplayDebug(uint texelX, uint texelY, float3 color)
{
    DebugTexture[uint2(texelX, texelY)] = float4(color, 1.);
}

[numthreads(16, 16, 1)]
void LBM_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    // lbm constants
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0., 0.);
    float rho = 1.;
    float feq[9];
    
    int boundary = 0;
    float f_fake = -1. * (texelX + 256 * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <=0 || texelY >= 255)
    {
        boundary = 1; // type 1 lattice
        /*
    
        1 2 3 
        4 0 5
        6 7 8
    
        */
        feq[0] = f_fake; // pos 0 does not matter, will be overwriten later
        // below is a generalize of out boundary in x and y
        feq[1] = f_fake;
        feq[2] = f_fake;
        feq[3] = f_fake;
        feq[4] = f_fake;
        feq[5] = f_fake;
        feq[6] = f_fake;
        feq[7] = f_fake;
        feq[8] = f_fake;
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 30;
    SurfaceProperty Property;
    Property.phi = 0.0;
    Property.m = 0.;
    Property.m_ex = 0.;
    Property.flg_fluid = false;
    Property.flg_interface = false;
    Property.flg_gas = false;
    Property.flg_solid = false;
    Property.flg_i_to_g = false;
    Property.flg_i_to_f = false;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 0;
        u = float2(0.2, 0.);
        // fluid node
        Property.phi = 1.0;
        Property.flg_fluid = true;
        Property.m = 1.0;
    }
    else
    {
        Property.phi = 0.0;
        Property.flg_gas = true;
        Property.m = 0.0;
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float2(0.0, 0.0);
    }
    
    if (texelX == 255 && texelY > 0 &&  texelY < 255)
    {
        boundary = 3;
    }
    
    if (boundary >= 1)
    {
        Property.flg_solid = true;
        Property.flg_gas = false;
        Property.m = 0.0;
        Property.phi = 0.0;
    }
    //StoreFluidFraction(texelX, texelY, fluidFraction);
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < 9; i++)
        {
            feq[i] = w[i] * rho * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    StoreSimulationData2D(texelX, texelY, feq, boundary);
    StoreSurfaceProperty(texelX, texelY, Property);
    
    DebugTexture[uint2(texelX, texelY)].x = 1.;
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = 1.;
}

[numthreads(16, 16, 1)]
void LBM_InitialInterface(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    if (!surfaceProp.flg_fluid)
    {
        DebugTexture[uint2(texelX, texelY)] = float4(1., 1., 0., 1.);
        return;
    }
    bool toInterface = false;
    for (int i = 1; i < 9; i++)
    {
        // check all neighbors
        int2 c_i = int2((int) c[i].x, (int) c[i].y);
        SurfaceProperty NeighborProperty;
        ReadSurfaceProperty(texelX + c_i.x, texelY + c_i.y, NeighborProperty);
        if (!NeighborProperty.flg_fluid && !NeighborProperty.flg_interface)
        {
            toInterface = true;
            break;
        }
    }
    if (toInterface)
    {
        surfaceProp.flg_interface = true;
        surfaceProp.flg_fluid = false;
        surfaceProp.phi = 0.5;
        surfaceProp.m = 0.5;
    }
    DisplaySurfaceProp(texelX, texelY, surfaceProp);
    StoreSurfaceProperty(texelX, texelY, surfaceProp);
}

[numthreads(16, 16, 1)]
void LBM_Streaming(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    int texelX = (int)DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    int2 c[9] =
    {
        int2(0, 0),
        int2(-1, -1),
        int2(0, -1),
        int2(1, -1),
        int2(-1, 0),
        int2(1, 0),
        int2(-1, 1),
        int2(0, 1),
        int2(1, 1),
    };
    for (int i = 5; i < 9; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        ReadSimulationDataIndex2D(texelX, texelY, 9-i, f_1);
        ReadSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_2);
        StoreSimulationDataIndex2D(texelX, texelY, 9-i, f_2);
        StoreSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_1);
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[9], out float2 u, out float rho)
{
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    rho = 0.;
    u = float2(0., 0.);
    for (int i = 0; i < 9; i++)
    {
        rho += f[i];
        u += c[i] * f[i];
    }
    u = u / rho;
}

float GetEquilibrium(float2 u, float rho, float2 ci, float wi)
{
    return wi * rho * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}


[numthreads(16, 16, 1)]
void LBM_BoundaryTreatment(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    // lbm distribution functions
    float f[9];
    int boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);    
    float f_fake = -1. * (texelX + 256 * texelY);
    if (boundary == 1)
    {
        f[0] = f_fake;
        f[1] = f_fake;
        f[2] = f_fake;
        f[3] = f_fake;
        f[4] = f_fake;
        f[5] = f_fake;
        f[6] = f_fake;
        f[7] = f_fake;
        f[8] = f_fake;
    }
    if (boundary == 2)
    {
        float2 u = float2(0.5, 0.);
        float p = 1.;
        u = float2(0.0, 0.0);
        for (int i = 0; i < 9; i++)
        {
            f[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    if (boundary == 3 && texelY == 1)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY + 1, f, boundary_left);
    }
    else if (boundary == 3 && texelY == 254)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY - 1, f, boundary_left);
    }
    else if (boundary == 3)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY, f, boundary_left);
    }
    if (boundary == 0)
    {
        // bounce back
        for (int i = 1; i < 9; i++)
        {
            if (f[i] < 0. && f[9 - i] < 0.)
            {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            /*float q = 1. + f_streamed[i] / length(c[i]);
            float p_b_prev = 0.;
            float2 u_b_prev = 0.;
            GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float2(0.0, 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
                + q / (1. + q) * f[9 - i].x;
            f_streamed[i] = f_b;
            */
            // classical bounce-back
                f[i] = 0.;
                f[9 - i] = 0.;
            }
            else if (f[i] < 0.)
            {
                f[i] = f[9 - i];
            }
        }
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}


[numthreads(16, 16, 1)]
void LBM_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    float4 debugValue = float4(0., 0., 0., 1.);
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    if (!surfaceProp.flg_fluid && !surfaceProp.flg_interface)
    {
        if (surfaceProp.flg_gas)
        {
            float f[9];
            float2 u = float2(0., 0.);
            float rho = 1.;
            for (int i = 0; i < 9; i++)
            {
                f[i] = GetEquilibrium(u, rho, c[i], w[i]);
            }
            
            StoreSimulationData2D(texelX, texelY, f, 0);
        }
        return;
    }
    
    
    // lbm distribution functions
    float f[9];
    int boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    
    if (boundary >= 1)
    {
        return;
    }
    
    float rho = 0.;
    float2 u = float2(0., 0.);
    
    GetVelocityAndDensity(f, u, rho);
    
    // collision
    float cs = 1. / sqrt(3.);
    float feq[9];
    for (int i = 0; i < 9; i++)
    {
        feq[i] = GetEquilibrium(u, rho, c[i], w[i]);
        f[i] = f[i] - (f[i] - feq[i]) / 0.6;
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}

[numthreads(16, 16, 1)]
void LBM_AdvectMass(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    float f[9];
    float f_temp[9];
    int boundary = 0;
    
    float rho = 0.;
    float rho_gas = 1.; // TODO: using curvature
    float2 u = float2(0., 0.);
    ReadSimulationData2D(texelX, texelY, f, boundary);
    GetVelocityAndDensity(f, u, rho);
    
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    
    if (!surfaceProp.flg_fluid && !surfaceProp.flg_interface)
    {
        return;
    }
    
    // populate f_temp, aka DF after streaming
    
    for (int i = 1; i < 9; i++)
    {
        int2 c_i = int2((int) c[i].x, (int) c[i].y);
        ReadSimulationDataIndex2D(texelX - c_i.x, texelY - c_i.y, i, f_temp[i]);
        SurfaceProperty NeighborProperty;
        ReadSurfaceProperty(texelX - c_i.x, texelY - c_i.y, NeighborProperty);
        if (NeighborProperty.flg_solid)
        {
            f_temp[i] = GetEquilibrium(float2(0., 0.), rho, c[i], w[i]);
        }
        else if (NeighborProperty.flg_gas)
        {
            f_temp[i] = 
              GetEquilibrium(float2(0., 0.), rho_gas, c[i], w[i])
              + GetEquilibrium(float2(0., 0.), rho_gas, c[9 - i], w[9 - i]) + f[9 - i];
        }
    }
    
    // add neighbor excess mass
    for (int i = 1; i < 9; i++)
    {
        int2 c_i = int2((int) c[i].x, (int) c[i].y);
        SurfaceProperty NeighborProperty;
        ReadSurfaceProperty(texelX + c_i.x, texelY + c_i.y, NeighborProperty);
        surfaceProp.m += NeighborProperty.m_ex;
    }
    
    // mass advection (Lehmann2019 chapter 6.2)
    if (surfaceProp.flg_fluid)
    {
        for (int i = 1; i < 9; i++)
        {
            int2 c_i = int2((int) c[i].x, (int) c[i].y);
            // using grid DF before streaming, according to HOME-FS-LBM 2025 Eq (9)
            surfaceProp.m += f_temp[9 - i] - f[i];
        }
    }
    else if (surfaceProp.flg_interface)
    {
        for (int i = 1; i < 9; i++)
        {
            int2 c_i = int2((int) c[i].x, (int) c[i].y);
            SurfaceProperty NeighborProperty;
            ReadSurfaceProperty(texelX + c_i.x, texelY + c_i.y, NeighborProperty);
            if (NeighborProperty.flg_fluid)
            {
                surfaceProp.m += f_temp[9 - i] - f[i];
            }
            else if (NeighborProperty.flg_gas)
            {
                // no mass exchange, but reconstruct DF according to Eq (87)
                StoreSimulationDataIndex2D(texelX - c_i.x, texelY - c_i.y, i, f_temp[i]);
            }
            else if (NeighborProperty.flg_interface)
            {
                surfaceProp.m += (f_temp[9 - i] - f[i]) * 0.5 * (surfaceProp.phi + NeighborProperty.phi);
            }
        }
        
        // mark transition flags
        if (surfaceProp.m + surfaceProp.m_ex > 1.0 + 0.001)
        {
            surfaceProp.flg_i_to_f = true;
        }
        else if (surfaceProp.m + surfaceProp.m_ex < 0.0 - 0.001)
        {
            surfaceProp.flg_i_to_g = true;
        }
    }
    //DisplayDebug(texelX, texelY, float3(surfaceProp.m, 0., 1.));
    StoreSurfaceProperty(texelX, texelY, surfaceProp);
}

[numthreads(16, 16, 1)]
void LBM_Surface_1(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    for (int i = 1; i < 9; i++)
    {
        // check all neighbors
        int2 c_i = int2((int) c[i].x, (int) c[i].y);
        SurfaceProperty NeighborProperty;
        ReadSurfaceProperty(texelX + c_i.x, texelY + c_i.y, NeighborProperty);
        if (NeighborProperty.flg_i_to_f && surfaceProp.flg_i_to_g && !surfaceProp.flg_gas)
        {
            surfaceProp.flg_i_to_g = false;
        }
        else if (NeighborProperty.flg_i_to_f && surfaceProp.flg_gas)
        {
            surfaceProp.flg_i_to_g = true; // convert to interface later while flag gas and i_to_g both exist
        }
    }
    StoreSurfaceProperty(texelX, texelY, surfaceProp);
}


[numthreads(16, 16, 1)]
void LBM_Surface_2(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    
    // PART 1: Handle lattice points flagged with interface →gas AND gas
    // These are gas lattice points that need to be turned into interface
    if (surfaceProp.flg_i_to_g && surfaceProp.flg_gas)
    {
        // Initialize previously undefined DDFs by calculating equilibrium DDFs
        // using average density and velocity of all fluid OR interface neighbors
        float rho_avg = 0.;
        float2 u_avg = float2(0., 0.);
        int neighborCount = 0;
        
        // Iterate through all neighbors
        for (int i = 1; i < 9; i++)
        {
            int2 c_i = int2((int) c[i].x, (int) c[i].y);
            uint neighborX = texelX + c_i.x;
            uint neighborY = texelY + c_i.y;
            
            // Check bounds
            if (neighborX > 255 || neighborY > 255)
            {
                continue;
            }
            
            SurfaceProperty neighborProp;
            ReadSurfaceProperty(neighborX, neighborY, neighborProp);
            
            // Check if neighbor is fluid OR interface (which have well-defined properties)
            if (neighborProp.flg_fluid || neighborProp.flg_interface)
            {
                // Read distribution functions and compute density/velocity
                float f_neighbor[9];
                int boundary_neighbor = 0;
                ReadSimulationData2D(neighborX, neighborY, f_neighbor, boundary_neighbor);
                
                float rho_neighbor = 0.;
                float2 u_neighbor = float2(0., 0.);
                GetVelocityAndDensity(f_neighbor, u_neighbor, rho_neighbor);
                
                // Accumulate for averaging
                rho_avg += rho_neighbor;
                u_avg += u_neighbor;
                neighborCount++;
            }
        }
        
        // Compute average if we have neighbors
        if (neighborCount > 0)
        {
            rho_avg /= float(neighborCount);
            u_avg /= float(neighborCount);
            
            // Read existing boundary first
            int boundary = 0;
            float f_old[9];
            ReadSimulationData2D(texelX, texelY, f_old, boundary);
            
            // Initialize DDFs with equilibrium distribution functions
            float f[9];
            for (int i = 0; i < 9; i++)
            {
                f[i] = GetEquilibrium(u_avg, rho_avg, c[i], w[i]);
            }
            
            // Store the initialized DDFs (boundary remains unchanged)
            StoreSimulationData2D(texelX, texelY, f, boundary);
            
            // Note: We do NOT change the flags here to avoid race condition
            // The lattice point remains with interface →gas AND gas flags set
            // Conversion will be done later
        }
    }
    
    // PART 2: Handle lattice points ONLY flagged with interface →gas (not gas)
    else if (surfaceProp.flg_i_to_g && !surfaceProp.flg_gas)
    {
        // Check all neighbors
        for (int i = 1; i < 9; i++)
        {
            int2 c_i = int2((int) c[i].x, (int) c[i].y);
            uint neighborX = texelX + c_i.x;
            uint neighborY = texelY + c_i.y;
            
            // Check bounds
            if (neighborX > 255 || neighborY > 255)
            {
                continue;
            }
            
            SurfaceProperty neighborProp;
            ReadSurfaceProperty(neighborX, neighborY, neighborProp);
            
            // If neighbor is flagged with either fluid or interface →fluid
            if (neighborProp.flg_fluid || neighborProp.flg_i_to_f)
            {
                // Clear both fluid and interface →fluid flags
                neighborProp.flg_fluid = false;
                neighborProp.flg_i_to_f = false;
                // Set interface flag, turning neighbor into interface point
                neighborProp.flg_interface = true;
                
                StoreSurfaceProperty(neighborX, neighborY, neighborProp);
            }
        }
    }
}

[numthreads(16, 16, 1)]
void LBM_Surface_3(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float rho_fluid = 1.0; // placeholder for fluid density
    float2 u = float2(0., 0.);
    SurfaceProperty surfaceProp;
    ReadSurfaceProperty(texelX, texelY, surfaceProp);
    surfaceProp.m_ex = 0.;
    // PART 1: Change lattice points with interface →gas AND gas flags to interface
    // Clear the interface →gas AND gas flags and set the interface flag
    if (surfaceProp.flg_i_to_g && surfaceProp.flg_gas)
    {
        // Clear interface →gas flag
        surfaceProp.flg_i_to_g = false;
        // Clear gas flag
        surfaceProp.flg_gas = false;
        // Set interface flag
        surfaceProp.flg_interface = true;
        
        // Immediately write the flag to memory
        StoreSurfaceProperty(texelX, texelY, surfaceProp);
    }
    if(surfaceProp.flg_interface && surfaceProp.flg_i_to_f)
    {
        // Clear flags and set to fluid
        surfaceProp.flg_i_to_f = false;
        surfaceProp.flg_interface = false;
        surfaceProp.flg_fluid = true;
        
        surfaceProp.m_ex = surfaceProp.m - rho_fluid; // carry over excess mass
        surfaceProp.m = rho_fluid;
        surfaceProp.phi = 1.0;
    }else if(surfaceProp.flg_interface && surfaceProp.flg_i_to_g)
    {
        // Clear flags and set to gas
        surfaceProp.flg_i_to_g = false;
        surfaceProp.flg_interface = false;
        surfaceProp.flg_gas = true;
        
        surfaceProp.m_ex = surfaceProp.m; // carry over excess mass
        surfaceProp.m = 0.0;
        surfaceProp.phi = 0.0;
    }
    else if(surfaceProp.flg_interface)
    {
        if(surfaceProp.m> rho_fluid + 0.001)
        {
            surfaceProp.m_ex = surfaceProp.m - rho_fluid - 0.001;
        }
        else if(surfaceProp.m < 0.)
        {
            surfaceProp.m_ex = surfaceProp.m + 0.001;
        }
        surfaceProp.m = clamp(surfaceProp.m, 0., rho_fluid);
        // Update phi
        surfaceProp.phi = clamp(surfaceProp.m / rho_fluid, 0., 1.);
    }
    int count = 0;
    for (int i = 1; i < 9; i++)
    {
        int2 c_i = int2((int) c[i].x, (int) c[i].y);
        uint neighborX = texelX + c_i.x;
        uint neighborY = texelY + c_i.y;
            
        // Check bounds
        if (neighborX > 255 || neighborY > 255)
        {
            continue;
        }
        SurfaceProperty nbProp;
        ReadSurfaceProperty(neighborX, neighborY, nbProp);
        if (nbProp.flg_fluid || nbProp.flg_interface || nbProp.flg_i_to_f || (nbProp.flg_i_to_g && nbProp.flg_gas))
        {
            if (!(nbProp.flg_i_to_g && !nbProp.flg_gas))
            {
                count += 1;
            }
        }
    }
    surfaceProp.m += count > 0 ? 0.0 : surfaceProp.m_ex;
    surfaceProp.m_ex = count > 0 ? surfaceProp.m_ex / count : 0.0;
    DisplaySurfaceProp(texelX, texelY, surfaceProp);
    StoreSurfaceProperty(texelX, texelY, surfaceProp);
}


[numthreads(16, 16, 1)]
void LBM_Reverse_DF(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    float f[9];
    int boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    
    // correct the DF, so this kernel must be called after streaming
    for (int i = 1; i < 5; i++)
    {
        float temp = f[i];
        f[i] = f[9 - i];
        f[9 - i] = temp;
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}

#define BLOCK_DIM_X 4
#define BLOCK_DIM_Y 4
#define BLOCK_DIM_Z 1
groupshared float f_shared[(BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * 10];

#define W0 4./9.
#define W1 1./36.
#define W2 1./9.

float Get2ndOrderDistributionAtIndexByMoments(float2 c_i, float3 m_xx_xy_yy)
{
    return 0.5 * 9. * (m_xx_xy_yy.x * (c_i.x * c_i.x - 1. / 3.) + m_xx_xy_yy.z * (c_i.y * c_i.y - 1. / 3.) + 2. * m_xx_xy_yy.y * c_i.x * c_i.y);
}

void StoreShared(in uint localX, in uint localY, in float f[9])
{
    for (int i = 0; i < 9; i++)
    {
        f_shared[i + 10 * localX + 10 * (BLOCK_DIM_X + 2) * localY] = f[i];
    }
}

void LoadSharedIndex(in uint localX, in uint localY, in int index, out float value)
{
    value = f_shared[index + 10 * localX + 10 * (BLOCK_DIM_X + 2) * localY];
}

// m_: x: m_xx, y: m_xy, z: m_yy
void ReadMomentRepSimulationData2D(in int texelX, in int texelY, out float rho, out float2 u_, out float3 m_, out int boundary)
{
    rho = asfloat(DebugBuffer[0 + 10 * texelX + 10 * 256 * texelY]);
    
    u_.x = asfloat(DebugBuffer[1 + 10 * texelX + 10 * 256 * texelY]);
    u_.y = asfloat(DebugBuffer[2 + 10 * texelX + 10 * 256 * texelY]);
    
    m_.x = asfloat(DebugBuffer[3 + 10 * texelX + 10 * 256 * texelY]);
    m_.y = asfloat(DebugBuffer[4 + 10 * texelX + 10 * 256 * texelY]);
    m_.z = asfloat(DebugBuffer[5 + 10 * texelX + 10 * 256 * texelY]);
    boundary = DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY];
}

void StoreMomentRepSimulationData2D(in int texelX, in int texelY, in float rho, in float2 u_, in float3 m_, in int boundary)
{
    DebugBuffer[0 + 10 * texelX + 10 * 256 * texelY] = asint(rho);
    
    DebugBuffer[1 + 10 * texelX + 10 * 256 * texelY] = asint(u_.x);
    DebugBuffer[2 + 10 * texelX + 10 * 256 * texelY] = asint(u_.y);
    
    DebugBuffer[3 + 10 * texelX + 10 * 256 * texelY] = asint(m_.x);
    DebugBuffer[4 + 10 * texelX + 10 * 256 * texelY] = asint(m_.y);
    DebugBuffer[5 + 10 * texelX + 10 * 256 * texelY] = asint(m_.z);
    DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY] = boundary;
}


[numthreads(16, 16, 1)]
void LBM_MR_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0., 0.);
    float rho = 0.03;
    
    int boundary = 0;
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <= 0 || texelY >= 255)
    {
        boundary = 1; // type 1 lattice
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 10;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 1;
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float2(0.1, 0.0);
        rho = 0.06;

    }
    if (texelX == 255 && texelY > 0 && texelY < 255)
    {
        boundary = 3;
    }
    float fluidFraction = 0.0;
    if (texelX < 128)
    {
        fluidFraction = 1.0;
    }
    if(texelX==128)
    {
        fluidFraction = 0.5;
    }
    StoreMomentRepSimulationData2D(texelX, texelY, rho, u, float3(0., 0., 0.), boundary);
    DebugTexture[uint2(texelX, texelY)].x = length(u);
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = rho;
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, 1)]
void LBM_MR_Streaming_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1; // skip the outer boundary
    uint block_x_dim = BLOCK_DIM_X;
    uint block_y_dim = BLOCK_DIM_Y;
    if (texelX > 254 || texelY > 254)
    {
        return;
    }
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float2 u_;
    float3 m_;
    
    // compute distribution functions from moments
    float f[9];
    float cs = 1. / sqrt(3.);
    
    // deal with halo cells
    int boundary2 = 0;
    if (tid.x == 0 && tid.y == 0)
    {
        // deal with four corners in this thread
        ReadMomentRepSimulationData2D(texelX - 1, texelY - 1, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x - 1 + 1, tid.y -1 + 1, f);
        
        ReadMomentRepSimulationData2D(texelX + block_x_dim, texelY - 1, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x + block_x_dim + 1, tid.y - 1 + 1, f);
        
        ReadMomentRepSimulationData2D(texelX - 1, texelY + block_y_dim, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x - 1 + 1, tid.y + block_y_dim + 1, f);
        
        ReadMomentRepSimulationData2D(texelX + block_x_dim, texelY + block_y_dim, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x + block_x_dim + 1, tid.y + block_y_dim + 1, f);
    }
    
    AllMemoryBarrierWithGroupSync();
    int2 offset = int2(0, 0);
    // left and right halos
    if (tid.x == 0 || tid.x == block_x_dim - 1)
    {
        if (tid.x == 0)
        {
            offset = int2(-1, 0);
        }
        if (tid.x == block_x_dim - 1)
        {
            offset = int2(1, 0);
        }
        ReadMomentRepSimulationData2D(texelX + offset.x, texelY + offset.y, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, f);
    }
    
    // upper and lower halos
    if (tid.y == 0 || tid.y == block_y_dim - 1)
    {
        if (tid.y == 0)
        {
            offset = int2(0, -1);
        }
        if (tid.y == block_y_dim - 1)
        {
            offset = int2(0, 1);
        }
        ReadMomentRepSimulationData2D(texelX + offset.x, texelY + offset.y, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, f);
    }
    
    int boundary;
    
    // actual cell
    ReadMomentRepSimulationData2D(texelX, texelY, rho, u_, m_, boundary);
    for (int i = 0; i < 9; i++)
    {
        f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
    }
    StoreShared(tid.x + 1, tid.y + 1, f);
    
    AllMemoryBarrierWithGroupSync();
    // STAGE 2 -- stream the group shared data and convert back to moments
    for (int i = 0; i < 9; i++)
    {
        int2 c_i = int2((int)c[i].x, (int)c[i].y);
        LoadSharedIndex(tid.x + 1 - c_i.x, tid.y + 1 - c_i.y, i, f[i]);
    }
    
    // STAGE 3 -- collide and write back the moments to global memory
    
    // compute moments from distribution functions
    if (boundary == 0)
    {
        rho = 0.;
        u_ = float2(0., 0.);
        m_ = float3(0., 0., 0.);
        for (int i = 0; i < 9; i++)
        {
            rho += f[i];
            u_ += c[i] * f[i];
            m_.x += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_.y += (c[i].x * c[i].y) * f[i];
            m_.z += (c[i].y * c[i].y - 1. / 3.) * f[i];
        }
        u_ /= rho;
        m_ /= rho;
    
        // collide using moments
        float omega = 1. / 0.6;
        m_.x = (1. - omega) * m_.x + omega * u_.x * u_.x;
        m_.y = (1. - omega) * m_.y + omega * u_.x * u_.y;
        m_.z = (1. - omega) * m_.z + omega * u_.y * u_.y;
    }
    if (boundary == 2)
    {
        u_ = float2(0.1, 0.0);
        rho = 0.06;
    }
    if (boundary == 3)
    {
        ReadMomentRepSimulationData2D(texelX - 1, texelY, rho, u_, m_, boundary);
    }
    
    StoreMomentRepSimulationData2D(texelX, texelY, rho, u_, m_, boundary);
    DebugTexture[uint2(texelX, texelY)].x = length(u_);
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = rho;
}