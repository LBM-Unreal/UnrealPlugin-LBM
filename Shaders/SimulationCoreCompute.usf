// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

float Scale;
float Translate;

RWStructuredBuffer<float> InputBuffer;
RWStructuredBuffer<float> OutputBuffer;
RWTexture2DArray<float4> SimulationDataArray;
RWTexture2D<float4> DebugTexture;
RWStructuredBuffer<int> DebugBuffer;

///////////////
//
// Lattice Types:
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////

void StoreSimulationData2D(in uint texelX, in uint texelY, in float f[9], in int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        DebugBuffer[i + 10 * texelX + 10 * 256 * texelY] = asint(f[i]);
    }
    DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY] = boundary;
}

void StoreSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + 10 * texelX + 10 * 256 * texelY], asint(f_i), _);
}

void ReadSimulationDataIndex2D(in uint texelX, in uint texelY, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + 10 * texelX + 10 * 256 * texelY]);
}

void ReadSimulationData2D(in uint texelX, in uint texelY, out float f[9], out int boundary)
{
    for (int i = 0; i < 9; i++)
    {
        f[i] = asfloat(DebugBuffer[i + 10 * texelX + 10 * 256 * texelY]);
    }
    boundary = DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY];
}

float sphere(float2 p, float2 center, float radius)
{
    return length(p - center) - radius;
}

[numthreads(16, 16, 1)]
void FunctionMultiply(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID: SV_GroupID)
{
    OutputBuffer[tid.x] = InputBuffer[tid.x] * Scale + Translate;
    uint texelX = GroupID.x * 16 + tid.x;
    uint texelY = GroupID.y * 16 + tid.y;
    SimulationDataArray[uint3(texelX, texelY, 0)].x = (float) tid.x / 16.;
    SimulationDataArray[uint3(texelX, texelY, 0)].y = (float) tid.y / 16.;
}

float2 GetBoundaryVelocity(uint texelX, uint texelY)
{
    float maxU = 0.05;
    return maxU;
}


[numthreads(16, 16, 1)]
void LBM_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    // lbm constants
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0., 0.);
    float p = 0.03;
    float feq[9];
    
    int boundary = 0;
    float f_fake = -1. * (texelX + 256 * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <=0 || texelY >= 255)
    {
        boundary = 1; // type 1 lattice
        /*
    
        1 2 3 
        4 0 5
        6 7 8
    
        */
        feq[0] = f_fake; // pos 0 does not matter, will be overwriten later
        // below is a generalize of out boundary in x and y
        feq[1] = f_fake;
        feq[2] = f_fake;
        feq[3] = f_fake;
        feq[4] = f_fake;
        feq[5] = f_fake;
        feq[6] = f_fake;
        feq[7] = f_fake;
        feq[8] = f_fake;
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 10;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 1;
        for (int i = 0; i < 9; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float2(0.1, 0.0);
        p = 0.06;

    }
    if (texelX == 255 && texelY > 0 &&  texelY < 255)
    {
        boundary = 3;
    }
    
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < 9; i++)
        {
            feq[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    
    StoreSimulationData2D(texelX, texelY, feq, boundary);
    
    DebugTexture[uint2(texelX, texelY)].x = 0.;
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = 0.;
}

[numthreads(16, 16, 1)]
void LBM_Streaming(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    int texelX = (int)DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    int2 c[9] =
    {
        int2(0, 0),
        int2(-1, -1),
        int2(0, -1),
        int2(1, -1),
        int2(-1, 0),
        int2(1, 0),
        int2(-1, 1),
        int2(0, 1),
        int2(1, 1),
    };
    for (int i = 5; i < 9; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        ReadSimulationDataIndex2D(texelX, texelY, 9-i, f_1);
        ReadSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_2);
        StoreSimulationDataIndex2D(texelX, texelY, 9-i, f_2);
        StoreSimulationDataIndex2D(texelX + c[i].x, texelY + c[i].y, i, f_1);
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[9], out float2 u, out float p)
{
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    p = 0.;
    u = float2(0., 0.);
    for (int i = 0; i < 9; i++)
    {
        p += f[i];
        u += c[i] * f[i];
    }
    u = u / p;
}

float GetEquilibrium(float2 u, float p, float2 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}

[numthreads(16, 16, 1)]
void LBM_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    // lbm distribution functions
    float f[9];
    int boundary = 0;
    
    ReadSimulationData2D(texelX, texelY, f, boundary);
    float f_fake = -1. * (texelX + 256 * texelY);
    if (boundary == 1)
    {
        f[0] = f_fake;
        f[1] = f_fake;
        f[2] = f_fake;
        f[3] = f_fake;
        f[4] = f_fake;
        f[5] = f_fake;
        f[6] = f_fake;
        f[7] = f_fake;
        f[8] = f_fake;
    }
    if (boundary == 2)
    {
        float2 u = float2(0.5, 0.);
        float p = 0.06;
        u = float2(0.1, 0.0);
        p = 0.06;
        for (int i = 0; i < 9; i++)
        {
            f[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    if (boundary == 3 && texelY==1)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY + 1, f, boundary_left);
    }
    else if (boundary == 3 && texelY == 254)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY - 1, f, boundary_left);
    }
    else if (boundary == 3)
    {
        float boundary_left;
        ReadSimulationData2D(texelX - 1, texelY, f, boundary_left);
    }
    if (boundary>=1) // no simulation inside solid 
    {
        DebugTexture[uint2(texelX, texelY)] = float4(1., 1., 1., 1.);
        for (int i = 1; i < 5; i++)
        {
            float temp = f[i];
            f[i] = f[9 - i];
            f[9 - i] = temp;
        }
        StoreSimulationData2D(texelX, texelY, f, boundary);
        return;
    }
    //ReadSimulationData2D_2(texelX, texelY, f_streamed, boundary);
    
    
    float p = 0.;
    float2 u = float2(0., 0.);
    
    // boundary treatment
    // bounce back
    for (int i = 1; i < 9; i++)
    {
        if (f[i] < 0. && f[9-i]<0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            /*float q = 1. + f_streamed[i] / length(c[i]);
            float p_b_prev = 0.;
            float2 u_b_prev = 0.;
            GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float2(0.0, 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
                + q / (1. + q) * f[9 - i].x;
            f_streamed[i] = f_b;
            */
            // classical bounce-back
            f[i] = 0.;
            f[9 - i] = 0.;
            DebugTexture[uint2(texelX, texelY)].xyz = float3(0.,1.,0.);
        }
        else if(f[i]<0.)
        {
            f[i] = f[9 - i];
            DebugTexture[uint2(texelX, texelY)].xyz = float3(1., 0., 0.);
        }
    }
    GetVelocityAndDensity(f, u, p);
    DebugTexture[uint2(texelX, texelY)].xyz = float3(length(u), 0., p);
    if (IsNaN(p) || IsNaN(length(u)) || p == 0. || length(u)==0.)
    {
        DebugTexture[uint2(texelX, texelY)].xyz = float3(1.,1.,1.);
    }
    
    // collision
    float cs = 1. / sqrt(3.);
    float feq[9];
    for (int i = 0; i < 9; i++)
    {
        feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        f[i] = f[i] - (f[i] - feq[i]) / 0.6;
    }
    for (int i = 1; i < 5; i++)
    {
        float temp = f[i];
        f[i] = f[9 - i];
        f[9 - i] = temp;
    }
    StoreSimulationData2D(texelX, texelY, f, boundary);
}

#define BLOCK_DIM_X 4
#define BLOCK_DIM_Y 4
#define BLOCK_DIM_Z 1
groupshared float f_shared[(BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * 10];

#define W0 4./9.
#define W1 1./36.
#define W2 1./9.

float Get2ndOrderDistributionAtIndexByMoments(float2 c_i, float3 m_xx_xy_yy)
{
    return 0.5 * 9. * (m_xx_xy_yy.x * (c_i.x * c_i.x - 1. / 3.) + m_xx_xy_yy.z * (c_i.y * c_i.y - 1. / 3.) + 2. * m_xx_xy_yy.y * c_i.x * c_i.y);
}

void StoreShared(in uint localX, in uint localY, in float f[9])
{
    for (int i = 0; i < 9; i++)
    {
        f_shared[i + 10 * localX + 10 * (BLOCK_DIM_X + 2) * localY] = f[i];
    }
}

void LoadSharedIndex(in uint localX, in uint localY, in int index, out float value)
{
    value = f_shared[index + 10 * localX + 10 * (BLOCK_DIM_X + 2) * localY];
}

// m_: x: m_xx, y: m_xy, z: m_yy
void ReadMomentRepSimulationData2D(in int texelX, in int texelY, out float rho, out float2 u_, out float3 m_, out int boundary)
{
    rho = asfloat(DebugBuffer[0 + 10 * texelX + 10 * 256 * texelY]);
    
    u_.x = asfloat(DebugBuffer[1 + 10 * texelX + 10 * 256 * texelY]);
    u_.y = asfloat(DebugBuffer[2 + 10 * texelX + 10 * 256 * texelY]);
    
    m_.x = asfloat(DebugBuffer[3 + 10 * texelX + 10 * 256 * texelY]);
    m_.y = asfloat(DebugBuffer[4 + 10 * texelX + 10 * 256 * texelY]);
    m_.z = asfloat(DebugBuffer[5 + 10 * texelX + 10 * 256 * texelY]);
    boundary = DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY];
}

void StoreMomentRepSimulationData2D(in int texelX, in int texelY, in float rho, in float2 u_, in float3 m_, in int boundary)
{
    DebugBuffer[0 + 10 * texelX + 10 * 256 * texelY] = asint(rho);
    
    DebugBuffer[1 + 10 * texelX + 10 * 256 * texelY] = asint(u_.x);
    DebugBuffer[2 + 10 * texelX + 10 * 256 * texelY] = asint(u_.y);
    
    DebugBuffer[3 + 10 * texelX + 10 * 256 * texelY] = asint(m_.x);
    DebugBuffer[4 + 10 * texelX + 10 * 256 * texelY] = asint(m_.y);
    DebugBuffer[5 + 10 * texelX + 10 * 256 * texelY] = asint(m_.z);
    DebugBuffer[9 + 10 * texelX + 10 * 256 * texelY] = boundary;
}


[numthreads(16, 16, 1)]
void LBM_MR_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    float cs = 1. / sqrt(3.);
    
    
    float2 u = float2(0., 0.);
    float rho = 0.03;
    
    int boundary = 0;
    // process all boundary settings
    if (texelX <= 0 || texelX >= 255 || texelY <= 0 || texelY >= 255)
    {
        boundary = 1; // type 1 lattice
    }
    // inside solid boundary
    float2 center = float2(128., 128.);
    float radius = 10;
    float d = sphere(float2(texelX, texelY), center, radius);
    if (d < 0.)
    {
        boundary = 1;
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float2(0.1, 0.0);
        rho = 0.06;

    }
    if (texelX == 255 && texelY > 0 && texelY < 255)
    {
        boundary = 3;
    }
    StoreMomentRepSimulationData2D(texelX, texelY, rho, u, float3(0., 0., 0.), boundary);
    DebugTexture[uint2(texelX, texelY)].x = length(u);
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = rho;
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, 1)]
void LBM_MR_Streaming_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1; // skip the outer boundary
    uint block_x_dim = BLOCK_DIM_X;
    uint block_y_dim = BLOCK_DIM_Y;
    if (texelX > 254 || texelY > 254)
    {
        return;
    }
    // LBM constants
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float2 u_;
    float3 m_;
    
    // compute distribution functions from moments
    float f[9];
    float cs = 1. / sqrt(3.);
    
    // deal with halo cells
    int boundary2 = 0;
    if (tid.x == 0 && tid.y == 0)
    {
        // deal with four corners in this thread
        ReadMomentRepSimulationData2D(texelX - 1, texelY - 1, rho, u_, m_, boundary2);
        // based on 2023 Ferrari equation (10)
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x - 1 + 1, tid.y -1 + 1, f);
        
        // deal with four corners in this thread
        ReadMomentRepSimulationData2D(texelX + block_x_dim, texelY - 1, rho, u_, m_, boundary2);
        // based on 2023 Ferrari equation (10)
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x + block_x_dim + 1, tid.y - 1 + 1, f);
        
        // deal with four corners in this thread
        ReadMomentRepSimulationData2D(texelX - 1, texelY + block_y_dim, rho, u_, m_, boundary2);
        // based on 2023 Ferrari equation (10)
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x - 1 + 1, tid.y + block_y_dim + 1, f);
        
        // deal with four corners in this thread
        ReadMomentRepSimulationData2D(texelX + block_x_dim, texelY + block_y_dim, rho, u_, m_, boundary2);
        // based on 2023 Ferrari equation (10)
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
    
        StoreShared(tid.x + block_x_dim + 1, tid.y + block_y_dim + 1, f);
    }
    
    AllMemoryBarrierWithGroupSync();
    int2 offset = int2(0, 0);
    // left and right halos
    if (tid.x == 0 || tid.x == block_x_dim - 1)
    {
        if (tid.x == 0)
        {
            offset = int2(-1, 0);
        }
        if (tid.x == block_x_dim - 1)
        {
            offset = int2(1, 0);
        }
        ReadMomentRepSimulationData2D(texelX + offset.x, texelY + offset.y, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, f);
    }
    
    // upper and lower halos
    if (tid.y == 0 || tid.y == block_y_dim - 1)
    {
        if (tid.y == 0)
        {
            offset = int2(0, -1);
        }
        if (tid.y == block_y_dim - 1)
        {
            offset = int2(0, 1);
        }
        ReadMomentRepSimulationData2D(texelX + offset.x, texelY + offset.y, rho, u_, m_, boundary2);
        for (int i = 0; i < 9; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, f);
    }
    
    int boundary;
    
    // actual cell
    ReadMomentRepSimulationData2D(texelX, texelY, rho, u_, m_, boundary);
    for (int i = 0; i < 9; i++)
    {
        f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
    }
    StoreShared(tid.x + 1, tid.y + 1, f);
    
    AllMemoryBarrierWithGroupSync();
    // STAGE 2 -- stream the group shared data and convert back to moments
    for (int i = 0; i < 9; i++)
    {
        int2 c_i = int2((int)c[i].x, (int)c[i].y);
        LoadSharedIndex(tid.x + 1 - c_i.x, tid.y + 1 - c_i.y, i, f[i]);
    }
    
    // STAGE 3 -- collide and write back the moments to global memory
    
    // compute moments from distribution functions
    if (boundary == 0)
    {
        rho = 0.;
        u_ = float2(0., 0.);
        m_ = float3(0., 0., 0.);
        for (int i = 0; i < 9; i++)
        {
            rho += f[i];
            u_ += c[i] * f[i];
            m_.x += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_.y += (c[i].x * c[i].y) * f[i];
            m_.z += (c[i].y * c[i].y - 1. / 3.) * f[i];
        }
        u_ /= rho;
        m_ /= rho;
    
        // collide using moments
        float omega = 1. / 0.6;
        m_.x = (1. - omega) * m_.x + omega * u_.x * u_.x;
        m_.y = (1. - omega) * m_.y + omega * u_.x * u_.y;
        m_.z = (1. - omega) * m_.z + omega * u_.y * u_.y;
    }
    if (boundary == 2)
    {
        u_ = float2(0.1, 0.0);
        rho = 0.06;
    }
    if (boundary == 3)
    {
        ReadMomentRepSimulationData2D(texelX - 1, texelY, rho, u_, m_, boundary);
    }
    
    StoreMomentRepSimulationData2D(texelX, texelY, rho, u_, m_, boundary);
    DebugTexture[uint2(texelX, texelY)].x = length(u_);
    DebugTexture[uint2(texelX, texelY)].y = 0.;
    DebugTexture[uint2(texelX, texelY)].z = rho;
}