// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

float Scale;
float Translate;

RWStructuredBuffer<float> InputBuffer;
RWStructuredBuffer<float> OutputBuffer;
RWTexture2DArray<float4> OutputTextureArray;
RWTexture2DArray<float4> OutputTextureArray2;
RWTexture2D<float4> DebugTexture;


float sphere(float2 p, float2 center, float radius)
{
    return length(p - center) - radius;
}

[numthreads(16, 16, 1)]
void FunctionMultiply(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID: SV_GroupID)
{
    OutputBuffer[tid.x] = InputBuffer[tid.x] * Scale + Translate;
    uint texelX = GroupID.x * 16 + tid.x;
    uint texelY = GroupID.y * 16 + tid.y;
    OutputTextureArray[uint3(texelX, texelY, 0)].x = (float) tid.x / 16.;
    OutputTextureArray[uint3(texelX, texelY, 0)].y = (float) tid.y / 16.;
}

float2 GetBoundaryVelocity(uint texelX, uint texelY)
{
    float maxU = 0.1;
    return float2(0., maxU * (-pow(texelY - 128., 2.) / 128. / 128. + 1.));
}


[numthreads(16, 16, 1)]
void LBM_InitialState(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    if (texelX > 255 || texelY > 255)
    {
        return;
    }
    float2 u = float2(0., 0.);
    float p = 0.03;
    
    // x==0 inflow
    if (texelX == 0) // skip the simulation boundaries
    {
        u = GetBoundaryVelocity(texelX, texelY);
        p = 0.05;
    }
    
    // use feq as initial values for streaming
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    float cs = 1. / sqrt(3.);
    float feq[9];
    DebugTexture[uint2(texelX, texelY)].x = 0.;
    
    float2 center = float2(128., 128.);
    float radius = 30.;
    
    if (sphere(float2((float) texelX, (float) texelY), center, radius) < 0.)
    {
        u = 0;
        for (int i = 0; i < 9; i++)
        {
            OutputTextureArray[uint3(texelX, texelY, i)].y = 0.0;
        }
    }
    else
    {
        for (int i = 0; i < 9; i++)
        {
            OutputTextureArray[uint3(texelX, texelY, i)].y = 1.0;
        }
    }
    
    for (int i = 0; i < 9; i++)
    {
        feq[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        OutputTextureArray[uint3(texelX, texelY, i)].x = feq[i];
    }
    DebugTexture[uint2(texelX, texelY)].x = (float) texelX / 256.;
    DebugTexture[uint2(texelX, texelY)].y = length(u);
    DebugTexture[uint2(texelX, texelY)].z = p;
}

[numthreads(16, 16, 1)]
void LBM_Streaming(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    
    float2 center = float2(128., 128.);
    float radius = 30.;
    if (sphere(float2((float) texelX, (float) texelY), center, radius) < 0.)
    {
        for (int i = 0; i < 9; i++)
        {
            OutputTextureArray[uint3(texelX, texelY, i)].y = 0.0;
        }
    }
    else
    {
        for (int i = 0; i < 9; i++)
        {
            OutputTextureArray[uint3(texelX, texelY, i)].y = 1.0;
        }
    }
    /*if (OutputTextureArray[uint3(texelX, texelY, 0)].y == 0.)
    {
        return;
    }*/
    
    OutputTextureArray2[uint3(texelX, texelY, 0)] = OutputTextureArray[uint3(texelX, texelY, 0)];
    if (texelX < 255 && texelY < 255)
    {
        OutputTextureArray2[uint3(texelX, texelY, 1)] = OutputTextureArray[uint3(texelX + 1, texelY + 1, 1)];
    }
    if (texelY < 255)
    {
        OutputTextureArray2[uint3(texelX, texelY, 2)] = OutputTextureArray[uint3(texelX, texelY + 1, 2)];
    }
    if (texelX > 0 && texelY < 255)
    {
        OutputTextureArray2[uint3(texelX, texelY, 3)] = OutputTextureArray[uint3(texelX - 1, texelY + 1, 3)];
    }
    if (texelX < 255)
    {
        OutputTextureArray2[uint3(texelX, texelY, 4)] = OutputTextureArray[uint3(texelX + 1, texelY, 4)];
    }
    if (texelX > 0)
    {
        OutputTextureArray2[uint3(texelX, texelY, 5)] = OutputTextureArray[uint3(texelX - 1, texelY, 5)];
    }
    if (texelX < 255 & texelY > 0)
    {
        OutputTextureArray2[uint3(texelX, texelY, 6)] = OutputTextureArray[uint3(texelX + 1, texelY - 1, 6)];
    }
    if (texelY > 0)
    {
        OutputTextureArray2[uint3(texelX, texelY, 7)] = OutputTextureArray[uint3(texelX, texelY - 1, 7)];
    }
    if (texelX > 0 && texelY > 0)
    {
        OutputTextureArray2[uint3(texelX, texelY, 8)] = OutputTextureArray[uint3(texelX - 1, texelY - 1, 8)];
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[9], out float2 u, out float p)
{
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    p = 0.;
    u = float2(0., 0.);
    for (int i = 0; i < 9; i++)
    {
        p += f[i];
        u += c[i] * f[i];
    }
    u = u / p;
}

float GetEquilibrium(float2 u, float p, float2 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}

[numthreads(16, 16, 1)]
void LBM_Collision(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    
    float2 c[9] =
    {
        float2(0., 0.),
        float2(-1., -1.),
        float2(0., -1.),
        float2(1., -1.),
        float2(-1., 0.),
        float2(1., 0.),
        float2(-1., 1.),
        float2(0., 1.),
        float2(1., 1.),
    };
    
    float w[9] =
    {
        4. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 9.,
        1. / 36.,
        1. / 9.,
        1. / 36.,
    };
    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;    
    
    // boundary treatment
    
    // bounce back
    bool isBoundary = false;
    uint inds[3];
    if (texelX == 0 && texelY == 0)
    {
        isBoundary = true;
        // c[i] at 5, 7, 8
        inds[0] = 5;
        inds[1] = 7;
        inds[2] = 8;
    }
    if (texelX == 255 && texelY == 0)
    {
        isBoundary = true;
        // c[i] at 4, 6, 7
        inds[0] = 4;
        inds[1] = 6;
        inds[2] = 7;
    }
    if (texelX == 0 && texelY == 255)
    {
        isBoundary = true;
        // c[i] at 2, 3, 5
        inds[0] = 2;
        inds[1] = 3;
        inds[2] = 5;
    }
    if (texelX == 255 && texelY == 255)
    {
        isBoundary = true;
        // c[i] at 1, 2, 4
        inds[0] = 1;
        inds[1] = 2;
        inds[2] = 4;
    }
    if (texelX == 255 && texelY != 0 && texelY != 255)
    {
        isBoundary = true;
        // c[i] at 1, 4, 6
        inds[0] = 1;
        inds[1] = 4;
        inds[2] = 6;
    }
    if (texelY == 0 && texelX != 0 && texelX != 255)
    {
        isBoundary = true;
        // c[i] at 6, 7, 8
        inds[0] = 6;
        inds[1] = 7;
        inds[2] = 8;
    }
    if (texelY == 255 && texelY != 0 && texelY != 255)
    {
        isBoundary = true;
        // c[i] at 1, 2, 3
        inds[0] = 1;
        inds[1] = 2;
        inds[2] = 3;
    }
    /*if (texelX == 0 && texelY != 0 && texelY != 255)
    {
        isBoundary = true;
        // c[i] at 3, 5, 8
        inds[0] = 3;
        inds[1] = 5;
        inds[2] = 8;
    }*/
    if (isBoundary)
    {
        for (int i = 0; i < 3; i++)
        {
            OutputTextureArray2[uint3(texelX, texelY, i)] = OutputTextureArray2[uint3(texelX, texelY, 9 - i)];
        }
    }
    
    float p = 0.;
    float2 u = float2(0., 0.);
    
    float f[9];
    for (int i = 0; i < 9; i++)
    {
        f[i] = OutputTextureArray2[uint3(texelX, texelY, i)].x;
    }
    
    float f_prev[9];
    for (int i = 0; i < 9; i++)
    {
        f_prev[i] = OutputTextureArray[uint3(texelX, texelY, i)].x;
    }
    
    // boundary with known speed
    if (texelX == 0 && texelY != 0 && texelY != 255)
    {
        
        float2 u_prev = float2(0., 0.);
        float p_prev = 0.;
        GetVelocityAndDensity(f_prev, u_prev, p_prev);
        uint inds[3] = { 3, 5, 8 };
        for (int i = 0; i < 3; i++)
        {
            uint id = inds[i];
            float f_neq_opposite = f[9 - id] - GetEquilibrium(u_prev, p_prev, c[9 - id], w[9 - id]);
            float f_neq = f_neq_opposite; // bounce back the nonequilibrium part
            
            f[id] = GetEquilibrium(GetBoundaryVelocity(texelX, texelY), p_prev, c[id], w[id]) + f_neq;
            OutputTextureArray2[uint3(texelX, texelY, id)].x = f[id];
        }
    }
    
    GetVelocityAndDensity(f, u, p);
    DebugTexture[uint2(texelX, texelY)].x = length(u);
    DebugTexture[uint2(texelX, texelY)].z = p;
    if (IsNaN(p))
    {
        DebugTexture[uint2(texelX, texelY)].y = 0.5;
    }
    
    float2 center = float2(128., 128.);
    float radius = 30.;
    
    //DebugTexture[uint2(texelX, texelY)].z = OutputTextureArray2[uint3(texelX, texelY, 0)].y;
    
    for (int i = 0; i < 9; i++)
    {
        if (OutputTextureArray2[uint3(texelX, texelY, i)].y == 0. && i != 0)
        {
            float2 pos = float2((float) texelX, (float) texelY);
            float q = sphere(pos, center, radius) / length(c[i]);
            float p_b_prev = 0.;
            float2 u_b_prev = 0.;
            GetVelocityAndDensity(f_prev, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float2(0., 0.), p_b_prev, c[i], w[i]); // assume boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f_prev[i] - feq_b_prev)
                + q / (1. + q) * f_prev[9 - i].x;
            OutputTextureArray2[uint3(texelX, texelY, i)].x = f_b;
            f[i] = f_b;
        }
    }
    
    if (texelX == 0 || texelY == 0 || texelX == 255 || texelY == 255 
        || OutputTextureArray[uint3(texelX, texelY, 0)].y==0.) // skip the simulation boundaries
    {
        return;
    }
    
    float cs = 1. / sqrt(3.);
    float feq[9];
    for (int i = 0; i < 9; i++)
    {
        feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        f[i] = f[i] - (f[i] - feq[i]) / 0.8; // relaxation time tau = 0.1
    }
    
    for (int i = 0; i < 9; i++)
    {
        //if (IsNaN(f[i]) && i % 3 == 0)
        //{
        //    DebugTexture[uint2(texelX, texelY)].x = 1.;
        //}
        //else if (IsNaN(f[i]) && i % 3 == 1)
        //{
        //    DebugTexture[uint2(texelX, texelY)].y = 1.;
        //}
        //else if (IsNaN(f[i]) && i % 3 == 2)
        //{
        //    DebugTexture[uint2(texelX, texelY)].z = 1.;
        //}
        OutputTextureArray[uint3(texelX, texelY, i)].x = f[i];
    }
}