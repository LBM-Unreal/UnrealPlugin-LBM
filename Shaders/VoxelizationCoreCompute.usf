// VoxelizationCoreCompute.usf
#include "/Engine/Public/Platform.ush"

// Voxel grid buffer (UAV)
RWStructuredBuffer<uint> VoxelGridBuffer;
// Mesh data buffer (SRV)
StructuredBuffer<float> TriangleVerts;
StructuredBuffer<uint> TriangleIndices;

// Voxel grid parameters
float3 GridMin;
int3 GridDim;

// Mesh data parameters
float4x4 LocalToWorld;
uint TriangleCount;
uint VertexCount;
uint IndexCount;



//////////////////////////////////////////////////////////////////////////
// Helper Functions
void LoadVertexPosition(in uint vertex, out float3 pos)
{
    vertex = clamp(vertex, 0, VertexCount - 1);
    pos.x = TriangleVerts[vertex * 3 + 0];
    pos.y = TriangleVerts[vertex * 3 + 1];
    pos.z = TriangleVerts[vertex * 3 + 2];
}

void LoadTriangle(in uint triangleIdx, out float3 v0, out float3 v1, out float3 v2)
{
    uint i0 = clamp(TriangleIndices[triangleIdx * 3 + 0], 0, VertexCount - 1);
    uint i1 = clamp(TriangleIndices[triangleIdx * 3 + 1], 0, VertexCount - 1);
    uint i2 = clamp(TriangleIndices[triangleIdx * 3 + 2], 0, VertexCount - 1);

    LoadVertexPosition(i0, v0);
    LoadVertexPosition(i1, v1);
    LoadVertexPosition(i2, v2);
}

void writeOutput(float4 pos)
{
    uint idx = pos.x + pos.y * GridDim.x + pos.z * GridDim.x * GridDim.y;
    VoxelGridBuffer[idx] = 1;
}


//////////////////////////////////////////////////////////////////////////
// Algorithm Helper Functions
void SortVertices(inout float4 v0, inout float4 v1, inout float4 v2, in float4 pAxis)
{
	// TODO: sort v0, v1, v2 along pAxis
    float p0 = dot(v0, pAxis);
    float p1 = dot(v1, pAxis);
    float p2 = dot(v2, pAxis);
}

float4 PointInEdge(in float4 p0, in float4 p1, in float4 pAxis)
{
	// TODO: return point in edge p0-p1 at height h along primary axis
    return 0.0f;
}

float4 CalcFlatAdvance(in float4 pAxis, in float4 normal)
{
	// normal and pAxis have length 1.0f
    const float4 project = pAxis - normal * dot(normal, pAxis);

    return sign(project * (float4(1.f, 1.f, 1.f, 1.f) - pAxis));
}

float4 CalcPrimaryAxis(float4 v0, float4 v1, float4 v2)
{
    // TODO: optimize branching

    float4 maxV = max(v0, max(v1, v2));
    float4 minV = min(v0, min(v1, v2));

    float4 diff = pow(maxV - minV, 2);

    if (diff.x >= diff.y && diff.x >= diff.z)
    {
        return float4(1.f, 0.f, 0.f, 0.f);
    }
    else if (diff.y >= diff.x && diff.y >= diff.z)
    {
        return float4(0.f, 1.f, 0.f, 0.f);
    }
    else if (diff.z >= diff.x && diff.z >= diff.y)
    {
        return float4(0.f, 0.f, 1.f, 0.f);
    }

    return float4(0, 0, 0, 0);
}



//////////////////////////////////////////////////////////////////////////
// Algorithm Core Functions
void GapDetection(float4 voxel, float4 flatAdvance, float4 pAxis, float4 normal, float4 v0, float4 v1, float4 v2)
{
	// Calculate L0, point in the line, as the lower corner of the edge connecting this voxel to its opposite 12 neighbour
    float4 L0 = voxel + (flatAdvance > float4(0.f, 0.f, 0.f, 0.f));

	// Calculate P0, any point in the plane in this case we use the top vertex of the triangle
    float4 P0 = v0;

	// Calculate the intersection height over the current floor
    float distance = dot(P0 - L0, normal) / dot(pAxis, normal);

	// Gap Detection: intersection occurs in this floor and inside the triangle
    if (distance <= 1.0f)
	{
    	float4 oppositeVoxel = voxel + sign(flatAdvance);
        writeOutput(oppositeVoxel);
    }
}

void Scanline(float4 start, float4 end, float4 flatAdvance, float4 normal, float4 pAxis, float4 v0, float4 v1, float4 v2)
{
    const float4 d = end - start;
    const float4 step = sign(d);
	// steps is the sum of the components
    int steps = int(dot(floor(end) - floor(start), step));

	// Calculate tMax and tDelta
    const float4 tDelta = abs(float4(1.0f / d));
    float4 tMax = lerp((floor(start) - start) / d, (ceil(start) - start) / d, (d > float4(0.f, 0.f, 0.f, 0.f)));

	// first voxel
    float4 voxel = floor(start);
    writeOutput(voxel);
    GapDetection(voxel, flatAdvance, pAxis, normal, v0, v1, v2);
    while (steps-- >= 0)
    {
		// Determine the next 6Neighbour to visit
        const float4 minTMax = min(min(tMax.x, tMax.y), tMax.z);
        float4 TMaxStep = float4(minTMax == tMax);

    	// Bias opposing the flat advance Direction
        TMaxStep = lerp(TMaxStep, (TMaxStep != flatAdvance), dot(TMaxStep, TMaxStep) > 1.0f);
        voxel += TMaxStep * step;
        tMax += TMaxStep * tDelta;
        writeOutput(voxel);
        GapDetection(voxel, flatAdvance, pAxis, normal, v0, v1, v2);
    }
}

void VoxelizeTriangle(float4 v0, float4 v1, float4 v2, float4 normal)
{
	// Step 1 - Initialization
    float4 pAxis = CalcPrimaryAxis(v0, v1, v2);
    SortVertices( /*inout*/v0, /*inout*/v1, /*inout*/v2, pAxis);
    float4 flatAdvance = CalcFlatAdvance(pAxis, normal);

	// Step 2 - Interior Traversal stating
	// from v2’s height along the primary axis
    int h = int(dot(v2, pAxis));

	// Bottom half, up to v1’s height
    while (h <= int(dot(v1, pAxis)))
    {
        float4 start = PointInEdge(v2, v0, h);
        float4 end = PointInEdge(v2, v1, h);
        Scanline(start, end, flatAdvance, normal, pAxis, v0, v1, v2);
        h = h + 1;
    }

	// Top Half, up to v0’s height
    while (h <= int(dot(v0, pAxis)))
    {
        float4 start = PointInEdge(v2, v0, h);
        float4 end = PointInEdge(v1, v0, h);
        Scanline(start, end, flatAdvance, normal, pAxis, v0, v1, v2);
        h = h + 1;
    }

	// Step 3 - Edge Voxelization
    Scanline(v0, v1, flatAdvance, normal, pAxis, v0, v1, v2);
    Scanline(v1, v2, flatAdvance, normal, pAxis, v0, v1, v2);
    Scanline(v2, v0, flatAdvance, normal, pAxis, v0, v1, v2);
}


[numthreads(32, 1, 1)]
void VoxelizeMesh(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= TriangleCount) { return; }

    float3 vertices[3];
    LoadTriangle(DTid, vertices[0], vertices[1], vertices[2]);

    vertices[0] = mul(LocalToWorld, vertices[0]);
    vertices[1] = mul(LocalToWorld, vertices[1]);
    vertices[2] = mul(LocalToWorld, vertices[2]);

    VoxelizeTriangle(float4(vertices[0], 0), float4(vertices[1], 0), float4(vertices[1], 0), float4(0,0,0,0));  //TODO: add normal
}


/* ----------------- Copy Kernel ------------------------------------------------------------------------------------------------------*/ 
#define ELEMENT_DIM 20

RWStructuredBuffer<uint> CpySrcVoxelGridBuffer; // Voxel grid buffer (SRV)
// SimulationCore/FSimulationShaderResource3D.DebugBuffer
// Occupancy buffer at SimulationCore3DCompute.usf & 
RWStructuredBuffer<int> CpyDstDebugBuffer;


int3 SimDimension;
int3 VoxelGridDimension;

uint GetCpyDstIdx(in uint texelX, in uint texelY, in uint texelZ)
{
    return ELEMENT_DIM - 1 + ELEMENT_DIM * texelX + ELEMENT_DIM * SimDimension.x * texelY + ELEMENT_DIM * SimDimension.x * SimDimension.y * texelZ;
}


[numthreads(4, 4, 4)]
void CpyVoxelGridToSimulation(uint3 DTid : SV_DispatchThreadID)
{
    if (DTid.x >= VoxelGridDimension.x || DTid.y >= VoxelGridDimension.y || DTid.z >= VoxelGridDimension.z)
    {
	    return;
    }

    uint srcIdx = DTid.x + DTid.y * VoxelGridDimension.x + DTid.z * VoxelGridDimension.x * VoxelGridDimension.y;
    uint dstIdx = GetCpyDstIdx(DTid.x, DTid.y, DTid.z);

    if (CpySrcVoxelGridBuffer[srcIdx] > 0)
    {
        CpyDstDebugBuffer[dstIdx] = 1;
    }
    // CpyDstDebugBuffer[dstIdx] = 1;
}