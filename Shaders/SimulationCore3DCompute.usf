// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"
float InitialVelocity;
float InitialDensity;
float RelaxationFactor;
int3 SimDimension;
int DebugTextureSlice;
int4 c[20];
float4 w[20];
RWTexture2D<float4> DebugTexture;
RWTexture3D<half4> DebugTexture3D;
RWStructuredBuffer<int> DebugBuffer;
#define DIM_X SimDimension.x
#define DIM_Y SimDimension.y
#define DIM_Z SimDimension.z
#define BLOCK_DIM_X 8
#define BLOCK_DIM_Y 8
#define BLOCK_DIM_Z 8

#define DEBUG_TEXTURE_SLICE DebugTextureSlice

#define Q 19
#define ELEMENT_DIM 20

//groupshared float f_group[BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z * Q];

///////////////
//
// Lattice Types(boundary):
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
// 4: free-slip
//
///////////////
//
// Implement a D3Q19 LBM simulation
//
///////////////

/*
Grid structure:
Indices is different from the reference paper (hecht2010.pdf) since I let opposite c_i's indices sum to 19
.---->x
|\
| \
|  z
y

z=1
     .  5  .
     6  7  8
     .  9  .
z=0
     1  2  3
     4  0 15
    16 17 18
z=-1
    .  10  .
    11 12 13
    .  14  .

*/

uint GetBufferIndex3D(in uint texelX, in uint texelY, in uint texelZ)
{
    return ELEMENT_DIM * texelX + ELEMENT_DIM * SimDimension.x * texelY + ELEMENT_DIM * SimDimension.x * SimDimension.y * texelZ;
}

void StoreSimulationData3D(int group_offset, in uint texelX, in uint texelY, in uint texelZ, in int boundary)
{
    // 5 slices for each grid
    for (int i = 0; i < Q; i++)
    {
        DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)] = asint(f_group[i + group_offset]);
    }
    DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)] = boundary;
}

void StoreSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)], asint(f_i), _);
}

void ReadSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)]);
}
/*
void ReadSimulationData3D(int f_group_offset, in uint texelX, in uint texelY, in uint texelZ, out int boundary)
{
    for (int i = 0; i < Q; i++)
    {
        f_group[i + f_group_offset] = asfloat(DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)]);
    }
    boundary = DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)];
}*/

void StoreDebugTexture2D(in uint texelX, in uint texelY, in float4 value)
{
    DebugTexture[uint2(texelX, texelY)] = value;
}

void StoreDebugTexture3D(in uint texelX, in uint texelY, in uint texelZ, in float4 value)
{
    DebugTexture3D[uint3(texelX, texelY, texelZ)] = value;
}

void ReadBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, out float2 u, out float p)
{
    // TODO: for dynamic boundaries
}

void StoreBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, in float2 u, in float p)
{
    // TODO: for dynamic boundaries
}

float sphere3D(float3 p, float3 center, float radius)
{
    return length(p.xyz - center.xyz) - radius;
}

float GetEquilibrium(float3 u, float p, float3 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}


[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_InitialState3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{/*
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    // lbm constants D3Q19 see reference
    float cs = 1. / sqrt(3.);
    
    
    float3 u = float3(0., 0., 0.);
    float p = InitialDensity;
    float feq[Q];
    
    int boundary = 0;
    
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= SimDimension.x - 1 
        || texelY <= 0 || texelY >= SimDimension.y - 1 
        || texelZ <= 0 || texelZ >= SimDimension.z - 1)
    {
        boundary = 1; // type 1 lattice
        for (int i = 0; i < Q; i++)
        {
            feq[i] =  f_fake;
        }
        feq[0] = -1.; // pos 0 does not matter, will be overwriten later
    }
    // inside solid boundary
    float3 center = float3(SimDimension.x / 2., SimDimension.y / 2., SimDimension.z / 2.);
    float radius = 7;
    float d = sphere3D(float3(texelX, texelY, texelZ), center, radius);
    if (d < 0.)
    {
        boundary = 1;
        for (int i = 0; i < Q; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float3(InitialVelocity, 0., 0.);
        p = InitialDensity;

    }
    if (texelX == SimDimension.x - 1 && texelY > 0
        && texelY < SimDimension.y - 1 && texelZ > 0
        && texelZ < SimDimension.z - 1)
    {
        boundary = 3;
    }
    
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < Q; i++)
        {
            feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        }
    }
    for (int i = 0; i < Q; i++)
    {
        f_group[group_tid_offset + i] = feq[i];
    }
    
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(1., 0., 1., 1.));
    }*/
}
/*
void ReverseF(int group_offset)
{
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float temp = f_group[group_offset + i];
        f_group[group_offset + i] = f_group[group_offset + Q - i];
        f_group[group_offset + Q - i] = temp;
    }
}*/

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Streaming3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    *//*
    int texelX = (int) DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    int texelZ = (int) DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        if (texelZ + c[i].z < 0 || texelZ + c[i].z > 255)
        {
            continue;
        }
        ReadSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_1);
        ReadSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_2);
        StoreSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_2);
        StoreSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_1);
    }*/
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}
/*
void GetVelocityAndDensity(int group_offset, out float3 u, out float p)
{
    p = 0.;
    u = float3(0., 0., 0.);
    for (int i = 0; i < Q; i++)
    {
        p += f_group[group_offset + i];
        u += c[i] * f_group[group_offset + i];
    }
    u = u / p;
}*/

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_BoundaryTreatment3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{/*
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    
    // lbm distribution functions
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    int boundary = 0;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    ReadSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (boundary == 0)
    {
        return;
    }
    // boundary treatment
    
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    if (boundary == 1)
    {
        debugValue = float4(1., 0., 0., 1.);
        for (int i = 0; i < Q; i++)
        {
            f_group[group_tid_offset + i] = f_fake;
        }
    }
    if (boundary == 2)
    {
        debugValue = float4(0., 1., 0., 1.);
        float3 u = float3(InitialVelocity, 0., 0.);
        float p = InitialDensity;
        for (int i = 0; i < Q; i++)
        {
            f_group[group_tid_offset + i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    uint3 offset = uint3(-1, 0, 0);
    if (boundary == 3 && texelY == 1)
    {
        offset = uint3(-1, 1, 0);
    }
    else if (boundary == 3 && texelY == SimDimension.y - 2)
    {
        offset = uint3(-1, -1, 0);
    }
    else if (boundary == 3 && texelZ == 1)
    {
        offset = uint3(-1, 0, 1);
    }
    else if (boundary == 3 && texelZ == SimDimension.z - 2)
    {
        offset = uint3(-1, 0, -1);
    }
    if (boundary == 3)
    {
        debugValue = float4(1., 1., 1., 1.);
        float boundary_left;
        ReadSimulationData3D(group_tid_offset, texelX + offset.x, texelY + offset.y, texelZ + offset.z, boundary_left);
    }
    //ReverseF(group_tid_offset);
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, debugValue);
    }*/
}


[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{    /*
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    
    // lbm distribution functions
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    int boundary = 0;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    ReadSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    
    float p = 0.;
    float3 u = float3(0., 0., 0.);
    
    // bounce back
    for (int i = 1; i < Q; i++)
    {
        if (f_group[group_tid_offset + i] < 0. && f_group[group_tid_offset + Q - i] < 0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            //float q = 1. + f_streamed[i] / length(c[i]);
            //float p_b_prev = 0.;
            //float3 u_b_prev = 0.;
            //GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            //float feq_b = GetEquilibrium(float3(0., 0., 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            //float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            //float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
            //    + q / (1. + q) * f[19 - i].x;
            //f_streamed[i] = f_b;
            
            // classical bounce-back
            f_group[group_tid_offset + i] = 0.;
            f_group[group_tid_offset + Q - i] = 0.;
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
        else if (f_group[group_tid_offset + i] < 0.)
        {
            f_group[group_tid_offset + i] = f_group[group_tid_offset + Q - i];
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
    }
    
    GetVelocityAndDensity(group_tid_offset, u, p);
    debugValue.xyz = float3(length(u), 0., p);
    if (IsNaN(p) || IsNaN(length(u)) )
    {
        debugValue.xyz = float3(0., 1., 0.);
    }
    if (p == 0. || length(u) == 0.)
    {
        debugValue.xyz = float3(0., 0., 1.);
    }
    if (boundary >= 1)
    {
        debugValue.xyz = float3(1., 1., 1.);
    }
    // collision
    float cs = 1. / sqrt(3.);
    for (int i = 0; i < Q; i++)
    {
        f_group[group_tid_offset + i] = f_group[group_tid_offset + i] - (f_group[group_tid_offset + i] - GetEquilibrium(u, p, c[i], w[i])) / RelaxationFactor; // relaxation time tau = 0.1
    }
    ReverseF(group_tid_offset);
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, debugValue);
    }
    StoreDebugTexture3D(texelX, texelY, texelZ, float4(u, p));*/
}


struct Moment_
{
    float xx;
    float yy;
    float zz;
    float xy;
    float yz;
    float zx;
};

//groupshared float f_shared[(BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * (BLOCK_DIM_Z + 2) * 19];

float Get2ndOrderDistributionAtIndexByMoments(float3 c_i, in Moment_ m_)
{
    float contracted =
        m_.xx * (c_i.x * c_i.x - 1.0 / 3.0) +
        m_.yy * (c_i.y * c_i.y - 1.0 / 3.0) +
        m_.zz * (c_i.z * c_i.z - 1.0 / 3.0) +
        2.0 * m_.xy * c_i.x * c_i.y +
        2.0 * m_.zx * c_i.x * c_i.z +
        2.0 * m_.yz * c_i.y * c_i.z;

    return 0.5 * 9.0 * contracted;
}
/*
void StoreShared(in uint localX, in uint localY, in uint localZ, in float f[19])
{
    int l_index = 19 * (localX + (BLOCK_DIM_X + 2) * localY + (BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * localZ);
    for (int i = 0; i < 19; i++)
    {
        f_shared[i + l_index] = f[i];
    }
}


void StoreSharedIndex(in uint localX, in uint localY, in uint localZ, in int index, in float f_i)
{
    int l_index = 19 * (localX + (BLOCK_DIM_X + 2) * localY + (BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * localZ);
    f_shared[index + l_index] = f_i;
}

void LoadSharedIndex(in uint localX, in uint localY, in uint localZ, in int index, out float value)
{
    int l_index = 19 * (localX + (BLOCK_DIM_X + 2) * localY + (BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * localZ);
    value = f_shared[index + l_index];
}*/

void ReadMomentRepSimulationData3D(in int texelX, in int texelY, in int texelZ, out float rho, out float3 u_, out Moment_ m_, out int boundary)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    rho = asfloat(DebugBuffer[0 + ELEMENT_DIM * index]);
    
    u_.x = asfloat(DebugBuffer[1 + ELEMENT_DIM * index]);
    u_.y = asfloat(DebugBuffer[2 + ELEMENT_DIM * index]);
    u_.z = asfloat(DebugBuffer[3 + ELEMENT_DIM * index]);
    
    m_.xx = asfloat(DebugBuffer[4 + ELEMENT_DIM * index]);
    m_.yy = asfloat(DebugBuffer[5 + ELEMENT_DIM * index]);
    m_.zz = asfloat(DebugBuffer[6 + ELEMENT_DIM * index]);
    m_.xy = asfloat(DebugBuffer[7 + ELEMENT_DIM * index]);
    m_.yz = asfloat(DebugBuffer[8 + ELEMENT_DIM * index]);
    m_.zx = asfloat(DebugBuffer[9 + ELEMENT_DIM * index]);
    
    boundary = DebugBuffer[10 + ELEMENT_DIM * index];
}

void StoreMomentRepSimulationData3D(in int texelX, in int texelY, in int texelZ, in float rho, in float3 u_, in Moment_ m_, in int boundary)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    DebugBuffer[0 + ELEMENT_DIM * index] = asint(rho);
    
    DebugBuffer[1 + ELEMENT_DIM * index] = asint(u_.x);
    DebugBuffer[2 + ELEMENT_DIM * index] = asint(u_.y);
    DebugBuffer[3 + ELEMENT_DIM * index] = asint(u_.z);
    
    DebugBuffer[4 + ELEMENT_DIM * index] = asint(m_.xx);
    DebugBuffer[5 + ELEMENT_DIM * index] = asint(m_.yy);
    DebugBuffer[6 + ELEMENT_DIM * index] = asint(m_.zz);
    DebugBuffer[7 + ELEMENT_DIM * index] = asint(m_.xy);
    DebugBuffer[8 + ELEMENT_DIM * index] = asint(m_.yz);
    DebugBuffer[9 + ELEMENT_DIM * index] = asint(m_.zx);
    
    DebugBuffer[10 + ELEMENT_DIM * index] = boundary;
}

void ReadBoundaryInfo3D(in int texelX, in int texelY, in int texelZ, out int boundary, out float3 normal, out float dist)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    boundary = DebugBuffer[10 + ELEMENT_DIM * index];
    normal.x = asfloat(DebugBuffer[11 + ELEMENT_DIM * index]);
    normal.y = asfloat(DebugBuffer[12 + ELEMENT_DIM * index]);
    normal.z = asfloat(DebugBuffer[13 + ELEMENT_DIM * index]);
    dist = asfloat(DebugBuffer[14 + ELEMENT_DIM * index]);
}

void StoreBoundaryInfo3D(in int texelX, in int texelY, in int texelZ, in int boundary, in float3 normal, in float dist)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    DebugBuffer[10 + ELEMENT_DIM * index] = boundary;
    DebugBuffer[11 + ELEMENT_DIM * index] = asint(normal.x);
    DebugBuffer[12 + ELEMENT_DIM * index] = asint(normal.y);
    DebugBuffer[13 + ELEMENT_DIM * index] = asint(normal.z);
    DebugBuffer[14 + ELEMENT_DIM * index] = asint(dist);

}

#define INIT_VELO 0.2
#define MAX_VELO 0.3

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_MR_InitialState3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX >= SimDimension.x || texelY >= SimDimension.y || texelZ >= SimDimension.z)
    {
        return;
    }
    float cs = 1. / sqrt(3.);
    
    
    float3 u = float3(0., 0., 0.);
    float rho = 0.3;
    
    int boundary = 0;
    float3 normal = float3(0., 0., 0.);
    // process all boundary settings
    if (texelX <= 0 || texelX >= SimDimension.x-5 || 
        texelY <= 0 || texelY >= SimDimension.y-5 || 
        texelZ <= 0 || texelZ >= SimDimension.z-5 )
    {
        boundary = 4;
        if (texelX <= 0 || texelX >= SimDimension.x - 5)
        {
            normal = float3(1., 0., 0.);
        }
        if (texelY <= 0 || texelY >= SimDimension.y - 5)
        {
            normal = float3(0., 1., 0.);
        }
        if (texelZ <= 0 || texelZ >= SimDimension.z - 5)
        {
            normal = float3(0., 0., 1.);
        }
        StoreBoundaryInfo3D(texelX, texelY, texelZ, boundary, normal, 0.);
    }
    // inside solid boundary
    float3 center = float3(42., 128., 128.);
    float radius = 20;
    /*float d = sphere3D(float3(texelX, texelY, texelZ), center, radius);
    if (d < 0.)
    {
        boundary = 4;
        normal = normalize(float3(texelX, texelY, texelZ) - center);
        StoreBoundaryInfo3D(texelX, texelY, texelZ, boundary, normal, 0.);
    }*/
    
    if (texelX >= center.x - radius && texelX <= center.x+radius &&
        texelY >= center.y - radius && texelY <= center.y + radius &&
        texelZ >= center.z - radius && texelZ <= center.z + radius)
    {
        boundary = 4;
        normal = float3(0.,0.,0.);
        if (texelX == center.x - radius || texelX == center.x + radius)
        {
            normal = float3(1., 0., 0.);
        }
        else if (texelY == center.y - radius || texelY == center.y + radius)
        {
            normal = float3(0., 1., 0.);
        }
        else if (texelZ == center.z - radius || texelZ == center.z + radius)
        {
            normal = float3(0., 0., 1.);
        }
        StoreBoundaryInfo3D(texelX, texelY, texelZ, boundary, normal, 0.);
    }
    
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float3(0.0, 0.0, 0.0);
        rho = 0.35 * (128 - abs(texelY - 128)) * (128 - abs(texelZ - 128));
    }
    if (texelX == SimDimension.x - 5 && // right boundary as outflow
        texelY > 0 && texelY < SimDimension.y - 4 &&
        texelZ > 0 && texelZ < SimDimension.z - 4)
    {
        boundary = 3;
    }
    //StoreMomentRepSimulationData2D(texelX, texelY, rho, u, float3(0., 0., 0.), boundary);
    StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u, (Moment_)0, boundary);
    DebugTexture3D[uint3(texelX, texelY, texelZ)].x = 0.;
    DebugTexture3D[uint3(texelX, texelY, texelZ)].y = 0.;
    DebugTexture3D[uint3(texelX, texelY, texelZ)].z = 0.;
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(0., 0., 0., 1.));
    }
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_MR_Streaming_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1; 
    uint texelZ = DispatchThreadId.z + 1; // skip the outer boundary
    const uint block_x_dim = BLOCK_DIM_X;
    const uint block_y_dim = BLOCK_DIM_Y;
    const uint block_z_dim = BLOCK_DIM_Z;
    if (texelX >= SimDimension.x - 1 || texelY >= SimDimension.y - 1 || texelZ >= SimDimension.z - 1)
    {
        if (texelZ == DEBUG_TEXTURE_SLICE)
        {
            StoreDebugTexture2D(texelX, texelY, float4(0., 1., 0., 0));
        }
        return;
    }
    // LBM constants
    const float3 c[19] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    
    const float w[19] =
    {
        1. / 3.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
    };
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float3 u_;
    Moment_ m_;
    
    // compute distribution functions from moments
    float f[19];
    float cs = 1. / sqrt(3.);
    
    // deal with halo cells
    int boundary = 0;
    int boundary2 = 0;
    int3 offset = int3(0, 0, 0);
    /*
    // corner
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && 
        (tid.y == 0 || tid.y == block_y_dim - 1) && 
        (tid.z == 0 || tid.z == block_z_dim - 1)) 
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // borders
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.y == 0 || tid.y == block_y_dim - 1))
    // border along z axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along y axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along x axis
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // faces
    if ((tid.x == 0 || tid.x == block_x_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1))
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(0, 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // inner cell - only the center
    ReadMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    for (int i = 0; i < 19; i++)
    {
        f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
    }
    StoreShared(tid.x + 1, tid.y + 1, tid.z + 1, f);
    
    AllMemoryBarrierWithGroupSync();
    // STAGE 2 -- stream the group shared data and convert back to moments
    for (int i = 0; i < 19; i++)
    {
        int3 c_i = int3((int) c[i].x, (int) c[i].y, (int) c[i].z);
        LoadSharedIndex(tid.x + 1 - c_i.x, tid.y + 1 - c_i.y, tid.z + 1 - c_i.z, i, f[i]);
    }
    */
    // STAGE 3 -- collide and write back the moments to global memory
    
    // compute moments from distribution functions
    if (boundary == 0)
    {
        rho = 0.;
        u_ = float3(0., 0., 0.);
        m_ = (Moment_)0.;
        for (int i = 0; i < 19; i++)
        {
            rho += f[i];
            u_ += c[i] * f[i];
            m_.xx += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_.yy += (c[i].y * c[i].y - 1. / 3.) * f[i];
            m_.zz += (c[i].z * c[i].z - 1. / 3.) * f[i];
            m_.xy += (c[i].x * c[i].y) * f[i];
            m_.yz += (c[i].y * c[i].z) * f[i];
            m_.zx += (c[i].z * c[i].x) * f[i];
        }
        u_ /= rho;
        m_.xx /= rho;
        m_.yy /= rho;
        m_.zz /= rho;
        m_.xy /= rho;
        m_.yz /= rho;
        m_.zx /= rho;
    
        // collide using moments
        float omega = 1. / 0.501;
        m_.xx = (1. - omega) * m_.xx + omega * u_.x * u_.x;
        m_.yy = (1. - omega) * m_.yy + omega * u_.y * u_.y;
        m_.zz = (1. - omega) * m_.zz + omega * u_.z * u_.z;
        m_.xy = (1. - omega) * m_.xy + omega * u_.x * u_.y;
        m_.yz = (1. - omega) * m_.yz + omega * u_.y * u_.z;
        m_.zx = (1. - omega) * m_.zx + omega * u_.z * u_.x;
    }
    if (boundary == 2)
    {
        u_ = float3(INIT_VELO, 0.0, 0.0);
        rho = 0.03;
    }
    if (boundary == 3)
    {
        ReadMomentRepSimulationData3D(texelX - 1, texelY, texelZ, rho, u_, m_, boundary);
    }
    if (boundary==0)
    {
        StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    }
    DebugTexture3D[uint3(texelX, texelY, texelZ)].x = length(u_);
    DebugTexture3D[uint3(texelX, texelY, texelZ)].y = 0.;
    DebugTexture3D[uint3(texelX, texelY, texelZ)].z = rho;
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(length(u_), 0, rho, 0));
    }
}

float HOME_ReconstructFi_3D(
    in float rho,
    in float3 u,
    in Moment_ m_,
    in float3 ci,
    in float wi)
{
    rho = max(rho, 1e-8);
    if (length(u) > 0.3)
    {
        u = 0.3 * normalize(u);
    }
    // work around clamping m
    // for diagonal elements
    m_.xx = clamp(m_.xx, -0.25, 0.25);
    m_.yy = clamp(m_.yy, -0.25, 0.25);
    m_.zz = clamp(m_.zz, -0.25, 0.25);

    // for off-diagonal elements
    m_.xy = clamp(m_.xy, -0.08, 0.08);
    m_.zx = clamp(m_.zx, -0.08, 0.08);
    m_.yz = clamp(m_.yz, -0.08, 0.08);
    
    // 1st order
    float cu = ci.x * u.x + ci.y * u.y + ci.z * u.z;

    // 2nd order Hermite
    float H2_xx = ci.x * ci.x - 1.0 / 3.0;
    float H2_yy = ci.y * ci.y - 1.0 / 3.0;
    float H2_zz = ci.z * ci.z - 1.0 / 3.0;
    float H2_xy = ci.x * ci.y;
    float H2_xz = ci.x * ci.z;
    float H2_yz = ci.y * ci.z;
    float H2dotS =
          m_.xx * H2_xx
        + m_.yy * H2_yy
        + m_.zz * H2_zz
        + 2.0 * (m_.xy * H2_xy + m_.zx * H2_xz + m_.yz * H2_yz);

    // 3rd order Hermite
    float H3_xxy = ci.x * ci.x * ci.y - (1.0 / 3.0) * ci.y;
    float H3_xyy = ci.x * ci.y * ci.y - (1.0 / 3.0) * ci.x;
    float H3_xxz = ci.x * ci.x * ci.z - (1.0 / 3.0) * ci.z;
    float H3_xzz = ci.x * ci.z * ci.z - (1.0 / 3.0) * ci.x;
    float H3_yyz = ci.y * ci.y * ci.z - (1.0 / 3.0) * ci.z;
    float H3_yzz = ci.y * ci.z * ci.z - (1.0 / 3.0) * ci.y;
    float H3_xyz = ci.x * ci.y * ci.z;
    float thirdOrder =
          H3_xxy * (m_.xx * u.y + 2.0 * m_.xy * u.x - 2.0 * u.x * u.x * u.y)
        + H3_xyy * (m_.yy * u.x + 2.0 * m_.xy * u.y - 2.0 * u.x * u.y * u.y)
        + H3_xxz * (m_.xx * u.z + 2.0 * m_.zx * u.x - 2.0 * u.x * u.x * u.z)
        + H3_xzz * (m_.zz * u.x + 2.0 * m_.zx * u.z - 2.0 * u.x * u.z * u.z)
        + H3_yzz * (m_.zz * u.y + 2.0 * m_.yz * u.z - 2.0 * u.y * u.z * u.z)
        + H3_yyz * (m_.yy * u.z + 2.0 * m_.yz * u.y - 2.0 * u.y * u.y * u.z)
        + H3_xyz * (m_.zx * u.y + m_.yz * u.x + m_.xy * u.z - 2.0 * u.x * u.y * u.z);

    float poly =
          1.0
        + 3.0 * cu
        + 4.5 * H2dotS
        + 13.5 * thirdOrder;

    return rho * wi * poly;
}

void ApplySpecularOnMoment(Moment_ m, float rho, float3 u, float3 n, out float3 u_out, out Moment_ m_out)
{
    // 保证 n 是单位向量
    float nlen = length(n);
    if (nlen < 1e-6)
    {
        // fallback: 不做反射，返回原值
        u_out = u;
        m_out = m;
        return;
    }
    n = normalize(n);
    // -------- 1. 速度向量做镜面反射 --------
    // u' = u - 2 (u·n) n
    float dotUN = dot(u, n);
    float3 u_reflected = u - 2.0 * dotUN * n;
    
    // -------- 2. 构造反射矩阵 R = I - 2 n n^T --------
    float3x3 R =
    {
        1 - 2 * n.x * n.x, -2 * n.x * n.y, -2 * n.x * n.z,
        -2 * n.y * n.x, 1 - 2 * n.y * n.y, -2 * n.y * n.z,
        -2 * n.z * n.x, -2 * n.z * n.y, 1 - 2 * n.z * n.z
    };

    // -------- 3. 二阶矩做镜面反射 --------
    // Π' = R Π R^T
    float3x3 Pi = { m.xx, m.xy, m.zx, m.xy, m.yy, m.yz, m.zx, m.yz, m.zz };
    float3x3 Pi_reflected = mul(R, mul(Pi, transpose(R)));

    // -------- 4. 以上处理只作用于速度与二阶矩，密度保持不变 --------
    Moment_ outM = m;
    u_out = u_reflected;
    m_out.xx = Pi_reflected[0][0];
    m_out.xy = Pi_reflected[0][1];
    m_out.zx = Pi_reflected[0][2];
    m_out.yy = Pi_reflected[1][1];
    m_out.yz = Pi_reflected[1][2];
    m_out.zz = Pi_reflected[2][2];
}
/*
void LoadBlockDFIntoSharedMem(uint texelX, uint texelY, uint texelZ, uint3 tid, uint3 block_dim, int i,
   in out float rho,
   in out float3 u_,
   in out Moment_ m_)
{
    int i1 = i;
    float fi1 = 0.;
    int block_x_dim = block_dim.x;
    int block_y_dim = block_dim.y;
    int block_z_dim = block_dim.z;
    int boundary2;
    int3 offset = int3(0, 0, 0);
    // corner
    if ((tid.x == 0 || tid.x == block_x_dim - 1) &&
        (tid.y == 0 || tid.y == block_y_dim - 1) &&
        (tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    AllMemoryBarrierWithGroupSync();
    
    // borders
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.y == 0 || tid.y == block_y_dim - 1))
    // border along z axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along y axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along x axis
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
                //fi2 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    AllMemoryBarrierWithGroupSync();
    
    // faces
    if ((tid.x == 0 || tid.x == block_x_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
                //fi2 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1))
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    if ((tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(0, 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        if (boundary2 > 0)
        {
            fi1 = -boundary2;
        }
        else
        {
            fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
        }
        StoreSharedIndex(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, i1, fi1);
    }
    AllMemoryBarrierWithGroupSync();
    
    // inner cell - only the center
    ReadMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary2);
    if (boundary2 > 0)
    {
        fi1 = -boundary2;
            //fi2 = -boundary;
    }
    else
    {
        fi1 = HOME_ReconstructFi_3D(rho, u_, m_, c[i1], w[i1]);
    }
    StoreSharedIndex(tid.x + 1, tid.y + 1, tid.z + 1, i1, fi1);
    AllMemoryBarrierWithGroupSync();
}
*/

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_HOME_Streaming_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1;
    uint texelZ = DispatchThreadId.z + 1; // skip the outer boundary
    const uint block_x_dim = BLOCK_DIM_X;
    const uint block_y_dim = BLOCK_DIM_Y;
    const uint block_z_dim = BLOCK_DIM_Z;
    if (texelX >= SimDimension.x - 1 || texelY >= SimDimension.y - 1 || texelZ >= SimDimension.z - 1)
    {
        return;
    }
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float3 u_;
    Moment_ m_;
    int boundary = 0;
    
    // compute distribution functions from moments
    //float f[19];
    float cs = 1. / sqrt(3.);
    
    /*uint3 block_dim = uint3(block_x_dim, block_y_dim, block_z_dim);
    LoadBlockDFIntoSharedMem(texelX, texelY, texelZ, tid, block_dim, 0, rho, u_, m_);
    LoadSharedIndex(tid.x + 1 - c[0].x, tid.y + 1 - c[0].y, tid.z + 1 - c[0].z, 0, f[0]);
    
    for (int i = 1; i < 10; i++)
    {
        LoadBlockDFIntoSharedMem(texelX, texelY, texelZ, tid, block_dim, i, rho, u_, m_);
        //LoadBlockDFIntoSharedMem(texelX, texelY, texelZ, tid, block_dim, 19 - i, rho, u_, m_);
        LoadSharedIndex(tid.x + 1 - c[i].x, tid.y + 1 - c[i].y, tid.z + 1 - c[i].z, i, f[i]);
        //LoadSharedIndex(tid.x + 1 - c[19 - i].x, tid.y + 1 - c[19 - i].y, tid.z + 1 - c[19 - i].z, 19 - i, f[19 - i]);
    }*/
    
    ReadMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    
    if (boundary == 0)
    {
    // STAGE 2 -- stream the group shared data and convert back to moments
        float rho_star = 0.;
        float3 u_star = float3(0., 0., 0.);
        Moment_ m_star = (Moment_) 0.;
        float f_i;
        for (int i = 0; i < 19; i++)
        {
            int3 c_i = int3((int) c[i].x, (int) c[i].y, (int) c[i].z);
            uint3 StreamFrom = uint3(texelX, texelY, texelZ) - c[i].xyz;
        
            float rho2;
            float3 u_2;
            Moment_ m_2;
            int boundary2 = 0;
            ReadMomentRepSimulationData3D(StreamFrom.x, StreamFrom.y, StreamFrom.z, rho2, u_2, m_2, boundary2);
            f_i = HOME_ReconstructFi_3D(rho2, u_2, m_2, c[i], w[i]);
            if (boundary2 > 0) // neighbor is boundary
            {
                Moment_ m_boundary;
            // use rho for boundary, calculate u
                float3 u_boundary = float3(0., 0., 0.);
                if (boundary2 == 1)
                {
                    m_boundary = m_;
                }
                if (boundary2 == 2)
                {
                    u_boundary = float3(INIT_VELO, 0., 0.);
                    m_boundary.xx = u_boundary.x * u_boundary.x + (m_.xx - u_.x * u_.x);
                    m_boundary.xy = u_boundary.x * u_boundary.y + (m_.xy - u_.x * u_.y);
                    m_boundary.zx = u_boundary.x * u_boundary.z + (m_.zx - u_.x * u_.z);
                    m_boundary.yy = u_boundary.y * u_boundary.y + (m_.yy - u_.y * u_.y);
                    m_boundary.yz = u_boundary.y * u_boundary.z + (m_.yz - u_.y * u_.z);
                    m_boundary.zz = u_boundary.z * u_boundary.z + (m_.zz - u_.z * u_.z);
                }
                if (boundary2 == 3) // outlet or do-nothing boundary
                {
                    u_boundary = u_;
                    m_boundary = m_;
                }
                else if (boundary2 == 4) // free-slip
                {
                    float3 normal = float3(1., 0., 0.);
                    float dist;
                    int _;
                    ReadBoundaryInfo3D(texelX - c_i.x, texelY - c_i.y, texelZ - c_i.z, _, normal, dist);
                //float fluid_solid_drag = pow(length(u_), 2.);
                //u_boundary = u_ - normalize(normal) * dot(normal, u_); // use normal to do free slip
                    ApplySpecularOnMoment(m_, rho, u_, normal, u_boundary, m_boundary);
                }
                f_i = HOME_ReconstructFi_3D(rho, u_boundary, m_boundary, c[i], w[i]);
            }
            if (isnan(f_i))
            {
                f_i = 0.0001;
            }
            
            rho_star += f_i;
            u_star += c[i] * f_i;
            m_star.xx += (c[i].x * c[i].x - 1. / 3.) * f_i;
            m_star.yy += (c[i].y * c[i].y - 1. / 3.) * f_i;
            m_star.zz += (c[i].z * c[i].z - 1. / 3.) * f_i;
            m_star.xy += (c[i].x * c[i].y) * f_i;
            m_star.yz += (c[i].y * c[i].z) * f_i;
            m_star.zx += (c[i].z * c[i].x) * f_i;
        }
    
    // STAGE 3 -- collide and write back the moments to global memory
    // compute moments from distribution functions
    // reconstruct
        /*rho = 0.; // rho = rho_star
        for (int i = 0; i < 19; i++)
        {
            rho += f[i];
            u_star += c[i] * f[i];
            m_star.xx += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_star.yy += (c[i].y * c[i].y - 1. / 3.) * f[i];
            m_star.zz += (c[i].z * c[i].z - 1. / 3.) * f[i];
            m_star.xy += (c[i].x * c[i].y) * f[i];
            m_star.yz += (c[i].y * c[i].z) * f[i];
            m_star.zx += (c[i].z * c[i].x) * f[i];
        }*/
        rho = rho_star;
        rho = max(rho, 0.00001);
        u_star /= rho;
        m_star.xx /= rho;
        m_star.yy /= rho;
        m_star.zz /= rho;
        m_star.xy /= rho;
        m_star.yz /= rho;
        m_star.zx /= rho;
    
    // collide using moments
        float3 F = float3(0., 0., 0.);
        const float tau = RelaxationFactor;
        
        u_ = u_star + 0.5 * F / rho;
        
        m_.xx =
        (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.xx - m_star.yy - m_star.zz) +
        (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
        1.0 / (3.0 * tau) * (2.0 * u_star.x * u_star.x - u_star.y * u_star.y - u_star.z * u_star.z) +
        1.0 / rho * F.x * u_star.x +
        (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.x * u_star.x - F.y * u_star.y - F.z * u_star.z);
        m_.yy =
        (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.yy - m_star.xx - m_star.zz) +
        (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
        1.0 / (3.0 * tau) * (2.0 * u_star.y * u_star.y - u_star.x * u_star.x - u_star.z * u_star.z) +
        1.0 / rho * F.y * u_star.y +
        (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.y * u_star.y - F.x * u_star.x - F.z * u_star.z);
        m_.zz =
        (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.zz - m_star.yy - m_star.xx) +
        (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
        1.0 / (3.0 * tau) * (2.0 * u_star.z * u_star.z - u_star.y * u_star.y - u_star.x * u_star.x) +
        1.0 / rho * F.z * u_star.z +
        (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.z * u_star.z - F.y * u_star.y - F.x * u_star.x);
        m_.xy =
        (1.0 - 1.0 / tau) * m_star.xy +
        1.0 / tau * (u_star.x * u_star.y) +
        (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.x * u_star.y + F.y * u_star.x);
        m_.yz =
        (1.0 - 1.0 / tau) * m_star.yz +
        1.0 / tau * (u_star.y * u_star.z) +
        (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.y * u_star.z + F.z * u_star.y);
        m_.zx =
        (1.0 - 1.0 / tau) * m_star.zx +
        1.0 / tau * (u_star.z * u_star.x) +
        (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.x * u_star.z + F.z * u_star.x);
    }
    if (boundary == 3)
    {
        int b;
        ReadMomentRepSimulationData3D(texelX - 1, texelY, texelZ, rho, u_, m_, b);
    }
    if (boundary==0 || boundary==3)
    {
        StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    }
    DebugTexture3D[uint3(texelX, texelY, texelZ)] = float4(u_, rho);
    if (texelZ == DEBUG_TEXTURE_SLICE) {
        StoreDebugTexture2D(texelX, texelY, float4(length(u_) / 2./ INIT_VELO, boundary, rho, 1));
    }
}