// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"
float InitialVelocity;
float InitialDensity;
float RelaxationFactor;
int3 SimDimension;
int DebugTextureSlice;
int4 c[20];
float4 w[20];
RWTexture2D<float4> DebugTexture;
RWTexture3D<half4> DebugTexture3D;
RWStructuredBuffer<int> DebugBuffer;
#define DIM_X SimDimension.x
#define DIM_Y SimDimension.y
#define DIM_Z SimDimension.z
#define BLOCK_DIM_X 4
#define BLOCK_DIM_Y 4
#define BLOCK_DIM_Z 4

#define DEBUG_TEXTURE_SLICE DebugTextureSlice

#define Q 19
#define ELEMENT_DIM 20

groupshared float f_group[BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z * Q];

///////////////
//
// Lattice Types(boundary):
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////
//
// Implement a D3Q19 LBM simulation
//
///////////////

/*
Grid structure:
Indices is different from the reference paper (hecht2010.pdf) since I let opposite c_i's indices sum to 19
.---->x
|\
| \
|  z
y

z=1
     .  5  .
     6  7  8
     .  9  .
z=0
     1  2  3
     4  0 15
    16 17 18
z=-1
    .  10  .
    11 12 13
    .  14  .

*/

uint GetBufferIndex3D(in uint texelX, in uint texelY, in uint texelZ)
{
    return ELEMENT_DIM * texelX + ELEMENT_DIM * SimDimension.x * texelY + ELEMENT_DIM * SimDimension.x * SimDimension.y * texelZ;
}

void StoreSimulationData3D(int group_offset, in uint texelX, in uint texelY, in uint texelZ, in int boundary)
{
    // 5 slices for each grid
    for (int i = 0; i < Q; i++)
    {
        DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)] = asint(f_group[i + group_offset]);
    }
    DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)] = boundary;
}

void StoreSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)], asint(f_i), _);
}

void ReadSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)]);
}

void ReadSimulationData3D(int f_group_offset, in uint texelX, in uint texelY, in uint texelZ, out int boundary)
{
    for (int i = 0; i < Q; i++)
    {
        f_group[i + f_group_offset] = asfloat(DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)]);
    }
    boundary = DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)];
}

void StoreDebugTexture2D(in uint texelX, in uint texelY, in float4 value)
{
    DebugTexture[uint2(texelX, texelY)] = value;
}

void StoreDebugTexture3D(in uint texelX, in uint texelY, in uint texelZ, in float4 value)
{
    DebugTexture3D[uint3(texelX, texelY, texelZ)] = value;
}

void ReadBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, out float2 u, out float p)
{
    // TODO: for dynamic boundaries
}

void StoreBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, in float2 u, in float p)
{
    // TODO: for dynamic boundaries
}

float sphere3D(float3 p, float3 center, float radius)
{
    return length(p.xy - center.xy) - radius;
}

float GetEquilibrium(float3 u, float p, float3 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}


[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_InitialState3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    // lbm constants D3Q19 see reference
    float cs = 1. / sqrt(3.);
    
    
    float3 u = float3(0., 0., 0.);
    float p = InitialDensity;
    float feq[Q];
    
    int boundary = 0;
    
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= SimDimension.x - 1 
        || texelY <= 0 || texelY >= SimDimension.y - 1 
        || texelZ <= 0 || texelZ >= SimDimension.z - 1)
    {
        boundary = 1; // type 1 lattice
        for (int i = 0; i < Q; i++)
        {
            feq[i] =  f_fake;
        }
        feq[0] = -1.; // pos 0 does not matter, will be overwriten later
    }
    // inside solid boundary
    float3 center = float3(SimDimension.x / 2., SimDimension.y / 2., SimDimension.z / 2.);
    float radius = 7;
    float d = sphere3D(float3(texelX, texelY, texelZ), center, radius);
    if (d < 0.)
    {
        boundary = 1;
        for (int i = 0; i < Q; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float3(InitialVelocity, 0., 0.);
        p = InitialDensity;

    }
    if (texelX == SimDimension.x - 1 && texelY > 0
        && texelY < SimDimension.y - 1 && texelZ > 0
        && texelZ < SimDimension.z - 1)
    {
        boundary = 3;
    }
    
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < Q; i++)
        {
            feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        }
    }
    for (int i = 0; i < Q; i++)
    {
        f_group[group_tid_offset + i] = feq[i];
    }
    
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(1., 0., 1., 1.));
    }
}

void ReverseF(int group_offset)
{
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float temp = f_group[group_offset + i];
        f_group[group_offset + i] = f_group[group_offset + Q - i];
        f_group[group_offset + Q - i] = temp;
    }
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Streaming3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    int texelX = (int) DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    int texelZ = (int) DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        if (texelZ + c[i].z < 0 || texelZ + c[i].z > 255)
        {
            continue;
        }
        ReadSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_1);
        ReadSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_2);
        StoreSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_2);
        StoreSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_1);
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(int group_offset, out float3 u, out float p)
{
    p = 0.;
    u = float3(0., 0., 0.);
    for (int i = 0; i < Q; i++)
    {
        p += f_group[group_offset + i];
        u += c[i] * f_group[group_offset + i];
    }
    u = u / p;
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_BoundaryTreatment3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    
    // lbm distribution functions
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    int boundary = 0;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    ReadSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (boundary == 0)
    {
        return;
    }
    // boundary treatment
    
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    if (boundary == 1)
    {
        debugValue = float4(1., 0., 0., 1.);
        for (int i = 0; i < Q; i++)
        {
            f_group[group_tid_offset + i] = f_fake;
        }
    }
    if (boundary == 2)
    {
        debugValue = float4(0., 1., 0., 1.);
        float3 u = float3(InitialVelocity, 0., 0.);
        float p = InitialDensity;
        for (int i = 0; i < Q; i++)
        {
            f_group[group_tid_offset + i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    uint3 offset = uint3(-1, 0, 0);
    if (boundary == 3 && texelY == 1)
    {
        offset = uint3(-1, 1, 0);
    }
    else if (boundary == 3 && texelY == SimDimension.y - 2)
    {
        offset = uint3(-1, -1, 0);
    }
    else if (boundary == 3 && texelZ == 1)
    {
        offset = uint3(-1, 0, 1);
    }
    else if (boundary == 3 && texelZ == SimDimension.z - 2)
    {
        offset = uint3(-1, 0, -1);
    }
    if (boundary == 3)
    {
        debugValue = float4(1., 1., 1., 1.);
        float boundary_left;
        ReadSimulationData3D(group_tid_offset, texelX + offset.x, texelY + offset.y, texelZ + offset.z, boundary_left);
    }
    //ReverseF(group_tid_offset);
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, debugValue);
    }
}


[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    
    // lbm distribution functions
    uint group_tid_offset = (tid.x + BLOCK_DIM_X * tid.y + BLOCK_DIM_X * BLOCK_DIM_Y * tid.z) * Q;
    int boundary = 0;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    ReadSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    
    float p = 0.;
    float3 u = float3(0., 0., 0.);
    
    // bounce back
    for (int i = 1; i < Q; i++)
    {
        if (f_group[group_tid_offset + i] < 0. && f_group[group_tid_offset + Q - i] < 0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            //float q = 1. + f_streamed[i] / length(c[i]);
            //float p_b_prev = 0.;
            //float3 u_b_prev = 0.;
            //GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            //float feq_b = GetEquilibrium(float3(0., 0., 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            //float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            //float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
            //    + q / (1. + q) * f[19 - i].x;
            //f_streamed[i] = f_b;
            
            // classical bounce-back
            f_group[group_tid_offset + i] = 0.;
            f_group[group_tid_offset + Q - i] = 0.;
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
        else if (f_group[group_tid_offset + i] < 0.)
        {
            f_group[group_tid_offset + i] = f_group[group_tid_offset + Q - i];
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
    }
    
    GetVelocityAndDensity(group_tid_offset, u, p);
    debugValue.xyz = float3(length(u), 0., p);
    if (IsNaN(p) || IsNaN(length(u)) )
    {
        debugValue.xyz = float3(0., 1., 0.);
    }
    if (p == 0. || length(u) == 0.)
    {
        debugValue.xyz = float3(0., 0., 1.);
    }
    if (boundary >= 1)
    {
        debugValue.xyz = float3(1., 1., 1.);
    }
    // collision
    float cs = 1. / sqrt(3.);
    for (int i = 0; i < Q; i++)
    {
        f_group[group_tid_offset + i] = f_group[group_tid_offset + i] - (f_group[group_tid_offset + i] - GetEquilibrium(u, p, c[i], w[i])) / RelaxationFactor; // relaxation time tau = 0.1
    }
    ReverseF(group_tid_offset);
    StoreSimulationData3D(group_tid_offset, texelX, texelY, texelZ, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, debugValue);
    }
    StoreDebugTexture3D(texelX, texelY, texelZ, float4(u, p));
}


struct Moment_
{
    float xx;
    float yy;
    float zz;
    float xy;
    float yz;
    float zx;
};

groupshared float f_shared[(BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * (BLOCK_DIM_Z + 2) * 19];

float Get2ndOrderDistributionAtIndexByMoments(float3 c_i, in Moment_ m_)
{
    float contracted =
        m_.xx * (c_i.x * c_i.x - 1.0 / 3.0) +
        m_.yy * (c_i.y * c_i.y - 1.0 / 3.0) +
        m_.zz * (c_i.z * c_i.z - 1.0 / 3.0) +
        2.0 * m_.xy * c_i.x * c_i.y +
        2.0 * m_.zx * c_i.x * c_i.z +
        2.0 * m_.yz * c_i.y * c_i.z;

    return 0.5 * 9.0 * contracted;
}

void StoreShared(in uint localX, in uint localY, in uint localZ, in float f[19])
{
    int l_index = 19 * (localX + (BLOCK_DIM_X + 2) * localY + (BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * localZ);
    for (int i = 0; i < 19; i++)
    {
        f_shared[i + l_index] = f[i];
    }
}

void LoadSharedIndex(in uint localX, in uint localY, in uint localZ, in int index, out float value)
{
    int l_index = 19 * (localX + (BLOCK_DIM_X + 2) * localY + (BLOCK_DIM_X + 2) * (BLOCK_DIM_Y + 2) * localZ);
    value = f_shared[index + l_index];
}

void ReadMomentRepSimulationData3D(in int texelX, in int texelY, in int texelZ, out float rho, out float3 u_, out Moment_ m_, out int boundary)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    rho = asfloat(DebugBuffer[0 + 11 * index]);
    
    u_.x = asfloat(DebugBuffer[1 + 11 * index]);
    u_.y = asfloat(DebugBuffer[2 + 11 * index]);
    u_.z = asfloat(DebugBuffer[3 + 11 * index]);
    
    m_.xx = asfloat(DebugBuffer[4 + 11 * index]);
    m_.yy = asfloat(DebugBuffer[5 + 11 * index]);
    m_.zz = asfloat(DebugBuffer[6 + 11 * index]);
    m_.xy = asfloat(DebugBuffer[7 + 11 * index]);
    m_.yz = asfloat(DebugBuffer[8 + 11 * index]);
    m_.zx = asfloat(DebugBuffer[9 + 11 * index]);
    
    boundary = DebugBuffer[10 + 11 * index];
}

void StoreMomentRepSimulationData3D(in int texelX, in int texelY, in int texelZ, in float rho, in float3 u_, in Moment_ m_, in int boundary)
{
    uint index = texelX + SimDimension.x * texelY + SimDimension.x * SimDimension.y * texelZ;
    DebugBuffer[0 + 11 * index] = asint(rho);
    
    DebugBuffer[1 + 11 * index] = asint(u_.x);
    DebugBuffer[2 + 11 * index] = asint(u_.y);
    DebugBuffer[3 + 11 * index] = asint(u_.z);
    
    DebugBuffer[4 + 11 * index] = asint(m_.xx);
    DebugBuffer[5 + 11 * index] = asint(m_.yy);
    DebugBuffer[6 + 11 * index] = asint(m_.zz);
    DebugBuffer[7 + 11 * index] = asint(m_.xy);
    DebugBuffer[8 + 11 * index] = asint(m_.yz);
    DebugBuffer[9 + 11 * index] = asint(m_.zx);
    
    DebugBuffer[10 + 11 * index] = boundary;
}
#define INIT_VELO 0.2
[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_MR_InitialState3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX >= SimDimension.x || texelY >= SimDimension.y || texelZ >= SimDimension.z)
    {
        return;
    }
    float cs = 1. / sqrt(3.);
    
    
    float3 u = float3(0., 0., 0.);
    float rho = 0.3;
    
    int boundary = 0;
    // process all boundary settings
    if (texelX <= 0 || texelX >= SimDimension.x-1 || 
        texelY <= 0 || texelY >= SimDimension.y-1 || 
        texelZ <= 0 || texelZ >= SimDimension.z-1 )
    {
        boundary = 1; // type 1 lattice
    }
    // inside solid boundary
    float3 center = float3(42., 128., 128.);
    float radius = 20;
    float d = sphere3D(float3(texelX, texelY, texelZ), center, radius);
    if (d < 0.)
    {
        boundary = 1;
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float3(INIT_VELO, 0.0, 0.0);
        rho = 0.3;

    }
    if (texelX == SimDimension.x - 1 && 
        texelY > 0 && texelY < SimDimension.y - 1 &&
        texelZ > 0 && texelZ < SimDimension.z - 1)
    {
        boundary = 3;
    }
    float fluidFraction = 0.0;
    if (texelX < 128)
    {
        fluidFraction = 1.0;
    }
    if (texelX == 128)
    {
        fluidFraction = 0.5;
    }
    //StoreMomentRepSimulationData2D(texelX, texelY, rho, u, float3(0., 0., 0.), boundary);
    StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u, (Moment_)0, boundary);
    DebugTexture3D[uint3(texelX, texelY, texelZ)].x = length(u);
    DebugTexture3D[uint3(texelX, texelY, texelZ)].y = 0.;
    DebugTexture3D[uint3(texelX, texelY, texelZ)].z = rho;
	}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_MR_Streaming_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */

    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1; 
    uint texelZ = DispatchThreadId.z + 1; // skip the outer boundary
    const uint block_x_dim = BLOCK_DIM_X;
    const uint block_y_dim = BLOCK_DIM_Y;
    const uint block_z_dim = BLOCK_DIM_Z;
    if (texelX >= SimDimension.x - 1 || texelY >= SimDimension.y - 1 || texelZ >= SimDimension.z - 1)
    {
        if (texelZ == DEBUG_TEXTURE_SLICE)
        {
            StoreDebugTexture2D(texelX, texelY, float4(0., 1., 0., 0));
        }
        return;
    }
    // LBM constants
    const float3 c[19] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    
    const float w[19] =
    {
        1. / 3.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
    };
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float3 u_;
    Moment_ m_;
    
    // compute distribution functions from moments
    float f[19];
    float cs = 1. / sqrt(3.);
    
    // deal with halo cells
    int boundary2 = 0;
    int3 offset = int3(0, 0, 0);
    
    // corner
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && 
        (tid.y == 0 || tid.y == block_y_dim - 1) && 
        (tid.z == 0 || tid.z == block_z_dim - 1)) 
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // borders
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.y == 0 || tid.y == block_y_dim - 1))
    // border along z axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along y axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along x axis
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // faces
    if ((tid.x == 0 || tid.x == block_x_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1))
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(0, 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    int boundary;
    // inner cell - only the center
    ReadMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    for (int i = 0; i < 19; i++)
    {
        f[i] = rho * w[i] * (1. + 3. * dot(c[i], u_) + Get2ndOrderDistributionAtIndexByMoments(c[i], m_));
    }
    StoreShared(tid.x + 1, tid.y + 1, tid.z + 1, f);
    
    AllMemoryBarrierWithGroupSync();
    // STAGE 2 -- stream the group shared data and convert back to moments
    for (int i = 0; i < 19; i++)
    {
        int3 c_i = int3((int) c[i].x, (int) c[i].y, (int) c[i].z);
        LoadSharedIndex(tid.x + 1 - c_i.x, tid.y + 1 - c_i.y, tid.z + 1 - c_i.z, i, f[i]);
    }
    
    // STAGE 3 -- collide and write back the moments to global memory
    
    // compute moments from distribution functions
    if (boundary == 0)
    {
        rho = 0.;
        u_ = float3(0., 0., 0.);
        m_ = (Moment_)0.;
        for (int i = 0; i < 19; i++)
        {
            rho += f[i];
            u_ += c[i] * f[i];
            m_.xx += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_.yy += (c[i].y * c[i].y - 1. / 3.) * f[i];
            m_.zz += (c[i].z * c[i].z - 1. / 3.) * f[i];
            m_.xy += (c[i].x * c[i].y) * f[i];
            m_.yz += (c[i].y * c[i].z) * f[i];
            m_.zx += (c[i].z * c[i].x) * f[i];
        }
        u_ /= rho;
        m_.xx /= rho;
        m_.yy /= rho;
        m_.zz /= rho;
        m_.xy /= rho;
        m_.yz /= rho;
        m_.zx /= rho;
    
        // collide using moments
        float omega = 1. / 0.501;
        m_.xx = (1. - omega) * m_.xx + omega * u_.x * u_.x;
        m_.yy = (1. - omega) * m_.yy + omega * u_.y * u_.y;
        m_.zz = (1. - omega) * m_.zz + omega * u_.z * u_.z;
        m_.xy = (1. - omega) * m_.xy + omega * u_.x * u_.y;
        m_.yz = (1. - omega) * m_.yz + omega * u_.y * u_.z;
        m_.zx = (1. - omega) * m_.zx + omega * u_.z * u_.x;
    }
    if (boundary == 2)
    {
        u_ = float3(INIT_VELO, 0.0, 0.0);
        rho = 0.03;
    }
    if (boundary == 3)
    {
        ReadMomentRepSimulationData3D(texelX - 1, texelY, texelZ, rho, u_, m_, boundary);
    }
    if (boundary==0)
    {
        StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    }
    DebugTexture3D[uint3(texelX, texelY, texelZ)].x = length(u_);
    DebugTexture3D[uint3(texelX, texelY, texelZ)].y = 0.;
    DebugTexture3D[uint3(texelX, texelY, texelZ)].z = rho;
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(length(u_), 0, rho, 0));
    }
}

float HOME_ReconstructFi_3D(
    in float rho,
    in float3 u,
    in Moment_ m_,
    in float3 ci,
    in float wi)
{
    // 1st order
    float cu = ci.x * u.x + ci.y * u.y + ci.z * u.z;

    // 2nd order Hermite
    float H2_xx = ci.x * ci.x - 1.0 / 3.0;
    float H2_yy = ci.y * ci.y - 1.0 / 3.0;
    float H2_zz = ci.z * ci.z - 1.0 / 3.0;
    float H2_xy = ci.x * ci.y;
    float H2_xz = ci.x * ci.z;
    float H2_yz = ci.y * ci.z;
    float H2dotS =
          m_.xx * H2_xx
        + m_.yy * H2_yy
        + m_.zz * H2_zz
        + 2.0 * (m_.xy * H2_xy + m_.zx * H2_xz + m_.yz * H2_yz);

    // 3rd order Hermite
    float H3_xxy = ci.x * ci.x * ci.y - (1.0 / 3.0) * ci.y;
    float H3_xyy = ci.x * ci.y * ci.y - (1.0 / 3.0) * ci.x;
    float H3_xxz = ci.x * ci.x * ci.z - (1.0 / 3.0) * ci.z;
    float H3_xzz = ci.x * ci.z * ci.z - (1.0 / 3.0) * ci.x;
    float H3_yyz = ci.y * ci.y * ci.z - (1.0 / 3.0) * ci.z;
    float H3_yzz = ci.y * ci.z * ci.z - (1.0 / 3.0) * ci.y;
    float H3_xyz = ci.x * ci.y * ci.z;
    float thirdOrder =
          H3_xxy * (m_.xx * u.y + 2.0 * m_.xy * u.x - 2.0 * u.x * u.x * u.y)
        + H3_xyy * (m_.yy * u.x + 2.0 * m_.xy * u.y - 2.0 * u.x * u.y * u.y)
        + H3_xxz * (m_.xx * u.z + 2.0 * m_.zx * u.x - 2.0 * u.x * u.x * u.z)
        + H3_xzz * (m_.zz * u.x + 2.0 * m_.zx * u.z - 2.0 * u.x * u.z * u.z)
        + H3_yzz * (m_.zz * u.y + 2.0 * m_.yz * u.z - 2.0 * u.y * u.z * u.z)
        + H3_yyz * (m_.yy * u.z + 2.0 * m_.yz * u.y - 2.0 * u.y * u.y * u.z)
        + H3_xyz * (m_.zx * u.y + m_.yz * u.x + m_.xy * u.z - 2.0 * u.x * u.y * u.z);

    float poly =
          1.0
        + 3.0 * cu
        + 4.5 * H2dotS
        + 13.5 * thirdOrder;

    return rho * wi * poly;
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_HOME_Streaming_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */

    uint texelX = DispatchThreadId.x + 1;
    uint texelY = DispatchThreadId.y + 1;
    uint texelZ = DispatchThreadId.z + 1; // skip the outer boundary
    const uint block_x_dim = BLOCK_DIM_X;
    const uint block_y_dim = BLOCK_DIM_Y;
    const uint block_z_dim = BLOCK_DIM_Z;
    if (texelX >= SimDimension.x - 1 || texelY >= SimDimension.y - 1 || texelZ >= SimDimension.z - 1)
    {
        if (texelZ == DEBUG_TEXTURE_SLICE)
        {
            StoreDebugTexture2D(texelX, texelY, float4(0., 1., 0., 0));
        }
        return;
    }
    // LBM constants
    const float3 c[19] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    
    const float w[19] =
    {
        1. / 3.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
        1. / 18.,
        1. / 36.,
    };
    // STAGE 1 -- populate group shared memory with distrubution functions
    
    // read moments
    float rho;
    float3 u_;
    Moment_ m_;
    
    // compute distribution functions from moments
    float f[19];
    float cs = 1. / sqrt(3.);
    
    // deal with halo cells
    int boundary2 = 0;
    int3 offset = int3(0, 0, 0);
    
    // corner
    if ((tid.x == 0 || tid.x == block_x_dim - 1) &&
        (tid.y == 0 || tid.y == block_y_dim - 1) &&
        (tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // borders
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.y == 0 || tid.y == block_y_dim - 1))
    // border along z axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.x == 0 || tid.x == block_x_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along y axis
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1) && (tid.z == 0 || tid.z == block_z_dim - 1))
    // border along x axis
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    // faces
    if ((tid.x == 0 || tid.x == block_x_dim - 1))
    {
        offset = int3(1 - 2 * int(tid.x == 0), 0, 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.y == 0 || tid.y == block_y_dim - 1))
    {
        offset = int3(0, 1 - 2 * int(tid.y == 0), 0);
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    if ((tid.z == 0 || tid.z == block_z_dim - 1))
    {
        offset = int3(0, 0, 1 - 2 * int(tid.z == 0));
        ReadMomentRepSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, rho, u_, m_, boundary2);
        for (int i = 0; i < 19; i++)
        {
            f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
        }
        StoreShared(tid.x + offset.x + 1, tid.y + offset.y + 1, tid.z + offset.z + 1, f);
    }
    AllMemoryBarrierWithGroupSync();
    
    int boundary;
    // inner cell - only the center
    ReadMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    for (int i = 0; i < 19; i++)
    {
        f[i] = HOME_ReconstructFi_3D(rho, u_, m_, c[i], w[i]);
    }
    StoreShared(tid.x + 1, tid.y + 1, tid.z + 1, f);
    AllMemoryBarrierWithGroupSync();
    
    
    // STAGE 2 -- stream the group shared data and convert back to moments
    for (int i = 0; i < 19; i++)
    {
        int3 c_i = int3((int) c[i].x, (int) c[i].y, (int) c[i].z);
        LoadSharedIndex(tid.x + 1 - c_i.x, tid.y + 1 - c_i.y, tid.z + 1 - c_i.z, i, f[i]);
    }
    
    // STAGE 3 -- collide and write back the moments to global memory
    // compute moments from distribution functions
    if (boundary == 0)
    {
        // reconstruct
        rho = 0.;  // rho = rho_star
        float3 u_star = float3(0., 0., 0.);
        Moment_ m_star = (Moment_) 0.;
        for (int i = 0; i < 19; i++)
        {
            rho += f[i];
            u_star += c[i] * f[i];
            m_star.xx += (c[i].x * c[i].x - 1. / 3.) * f[i];
            m_star.yy += (c[i].y * c[i].y - 1. / 3.) * f[i];
            m_star.zz += (c[i].z * c[i].z - 1. / 3.) * f[i];
            m_star.xy += (c[i].x * c[i].y) * f[i];
            m_star.yz += (c[i].y * c[i].z) * f[i];
            m_star.zx += (c[i].z * c[i].x) * f[i];
        }
        u_star /= rho;
        m_star.xx /= rho;
        m_star.yy /= rho;
        m_star.zz /= rho;
        m_star.xy /= rho;
        m_star.yz /= rho;
        m_star.zx /= rho;
    
        // collide using moments
        float3 F = float3(0., 0., 0.);
        const float tau = 0.505;
        
        u_ = u_star + 0.5 * F / rho;
        
        m_.xx = 
            (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.xx - m_star.yy - m_star.zz) +
            (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
            1.0 / (3.0 * tau) * (2.0 * u_star.x * u_star.x - u_star.y * u_star.y - u_star.z * u_star.z) +
            1.0 / rho * F.x * u_star.x +
            (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.x * u_star.x - F.y * u_star.y - F.z * u_star.z);
        m_.yy =
            (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.yy - m_star.xx - m_star.zz) +
            (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
            1.0 / (3.0 * tau) * (2.0 * u_star.y * u_star.y - u_star.x * u_star.x - u_star.z * u_star.z) +
            1.0 / rho * F.y * u_star.y +
            (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.y * u_star.y - F.x * u_star.x - F.z * u_star.z);
        m_.zz =
            (tau - 1.0) / (3.0 * tau) * (2.0 * m_star.zz - m_star.yy - m_star.xx) +
            (1.0 / 3.0) * (u_star.x * u_star.x + u_star.y * u_star.y + u_star.z * u_star.z) +
            1.0 / (3.0 * tau) * (2.0 * u_star.z * u_star.z - u_star.y * u_star.y - u_star.x * u_star.x) +
            1.0 / rho * F.z * u_star.z +
            (tau - 1.0) / (3.0 * tau * rho) * (2.0 * F.z * u_star.z - F.y * u_star.y - F.x * u_star.x);
        m_.xy =
            (1.0 - 1.0 / tau) * m_star.xy +
            1.0 / tau * (u_star.x * u_star.y) +
            (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.x * u_star.y + F.y * u_star.x);
        m_.yz =
            (1.0 - 1.0 / tau) * m_star.yz +
            1.0 / tau * (u_star.y * u_star.z) +
            (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.y * u_star.z + F.z * u_star.y);
        m_.zx =
            (1.0 - 1.0 / tau) * m_star.zx +
            1.0 / tau * (u_star.z * u_star.x) +
            (2.0 * tau - 1.0) / (2.0 * tau * rho) * (F.x * u_star.z + F.z * u_star.x);
    }
    if (boundary == 2)
    {
        u_ = float3(INIT_VELO, 0.0, 0.0);
        rho = 0.3;
    }
    if (boundary == 3)
    {
        int b;
        ReadMomentRepSimulationData3D(texelX - 1, texelY, texelZ, rho, u_, m_, b);
    }
    if (boundary==0 || boundary==3)
    {
        StoreMomentRepSimulationData3D(texelX, texelY, texelZ, rho, u_, m_, boundary);
    }
    float g = 0.;
    if (boundary > 0)
    {
        g = 1.;
    }
    DebugTexture3D[uint3(texelX, texelY, texelZ)] = float4(u_, rho);
    if (texelZ == DEBUG_TEXTURE_SLICE) {
        StoreDebugTexture2D(texelX, texelY, float4(length(u_), g, rho, 0));
    }
}