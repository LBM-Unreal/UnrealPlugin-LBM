// SimulationCoreCompute.usf
#include "/Engine/Public/Platform.ush"
float InitialVelocity;
float InitialDensity;
float RelaxationFactor;
int3 SimDimension;
int DebugTextureSlice;
RWTexture2D<float4> DebugTexture;
RWTexture3D<half4> DebugTexture3D;
RWStructuredBuffer<int> DebugBuffer;

#define DIM_X SimDimension.x
#define DIM_Y SimDimension.y
#define DIM_Z SimDimension.z
#define BLOCK_DIM_X 8
#define BLOCK_DIM_Y 8
#define BLOCK_DIM_Z 8

#define DEBUG_TEXTURE_SLICE DebugTextureSlice

#define Q 19
#define ELEMENT_DIM 20

///////////////
//
// Lattice Types(boundary):
// 0: internal
// 1: solid boundary (with bounce-back behavior)
// 2: inlet
// 3: outlet
//
///////////////
//
// Implement a D3Q19 LBM simulation
//
///////////////

/*
Grid structure:
Indices is different from the reference paper (hecht2010.pdf) since I let opposite c_i's indices sum to 19
.---->x
|\
| \
|  z
y

z=1
     .  5  .
     6  7  8
     .  9  .
z=0
     1  2  3
     4  0 15
    16 17 18
z=-1
    .  10  .
    11 12 13
    .  14  .

*/

uint GetBufferIndex3D(in uint texelX, in uint texelY, in uint texelZ)
{
    return ELEMENT_DIM * texelX + ELEMENT_DIM * SimDimension.x * texelY + ELEMENT_DIM * SimDimension.x * SimDimension.y * texelZ;
}

void StoreSimulationData3D(in uint texelX, in uint texelY, in uint texelZ, in float f[Q], in int boundary)
{
    // 5 slices for each grid
    for (int i = 0; i < Q; i++)
    {
        DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)] = asint(f[i]);
    }
    DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)] = boundary;
}

void StoreSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, in float f_i)
{
    int _;
    InterlockedExchange(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)], asint(f_i), _);
}

void ReadSimulationDataIndex3D(in uint texelX, in uint texelY, in uint texelZ, in int index, out float f_i)
{
    f_i = asfloat(DebugBuffer[index + GetBufferIndex3D(texelX, texelY, texelZ)]);
}

void ReadSimulationData3D(in uint texelX, in uint texelY, in uint texelZ, out float f[Q], out int boundary)
{
    for (int i = 0; i < Q; i++)
    {
        f[i] = asfloat(DebugBuffer[i + GetBufferIndex3D(texelX, texelY, texelZ)]);
    }
    boundary = DebugBuffer[ELEMENT_DIM - 1 + GetBufferIndex3D(texelX, texelY, texelZ)];
}

void StoreDebugTexture2D(in uint texelX, in uint texelY, in float4 value)
{
    DebugTexture[uint2(texelX, texelY)] = value;
}

void StoreDebugTexture3D(in uint texelX, in uint texelY, in uint texelZ, in float4 value)
{
    DebugTexture3D[uint3(texelX, texelY, texelZ)] = value;
}

void ReadBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, out float2 u, out float p)
{
    // TODO: for dynamic boundaries
}

void StoreBoundaryValues3D(in uint texelX, in uint texelY, in uint texelZ, in float2 u, in float p)
{
    // TODO: for dynamic boundaries
}

float sphere3D(float3 p, float3 center, float radius)
{
    return length(p - center) - radius;
}

float GetEquilibrium(float3 u, float p, float3 ci, float wi)
{
    return wi * p * (1. + 3. * dot(ci, u) + 4.5 * pow(dot(ci, u), 2.) - 1.5 * dot(u, u));
}


[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_InitialState3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    // lbm constants D3Q19 see reference
    float w[Q] =
    {
        1. / 3., // [0]
        1. / 36., // [1 - 4]
        2. / 36.,
        1. / 36.,
        2. / 36.,
        1. / 36., // [5 - 9]
        1. / 36.,
        2. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 36., // [10 - 14]
        1. / 36.,
        2. / 36.,
        1. / 36.,
        1. / 36.,
        2. / 36., // [15 - 18]
        1. / 36.,
        2. / 36.,
        1. / 36.
    };
    
    float3 c[Q] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    float cs = 1. / sqrt(3.);
    
    
    float3 u = float3(0., 0., 0.);
    float p = InitialDensity;
    float feq[Q];
    
    int boundary = 0;
    
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    // process all boundary settings
    if (texelX <= 0 || texelX >= SimDimension.x - 1 
        || texelY <= 0 || texelY >= SimDimension.y - 1 
        || texelZ <= 0 || texelZ >= SimDimension.z - 1)
    {
        boundary = 1; // type 1 lattice
        for (int i = 0; i < Q; i++)
        {
            feq[i] =  f_fake;
        }
        feq[0] = -1.; // pos 0 does not matter, will be overwriten later
    }
    // inside solid boundary
    float3 center = float3(SimDimension.x / 2., SimDimension.y / 2., SimDimension.z / 2.);
    float radius = 10;
    float d = sphere3D(float3(texelX, texelY, texelZ), center, radius);
    if (d < 0.)
    {
        boundary = 1;
        for (int i = 0; i < Q; i++)
        {
            feq[i] = d;
        }
    }
    if (texelX == 0)
    {
        boundary = 2; // type 2 lattice with fixed velocity
        u = float3(InitialVelocity, 0., 0.);
        p = InitialDensity;

    }
    if (texelX == SimDimension.x - 1 && texelY > 0
        && texelY < SimDimension.y - 1 && texelZ > 0
        && texelZ < SimDimension.z - 1)
    {
        boundary = 3;
    }
    
    if (boundary == 0 || boundary == 2 || boundary == 3)
    {
        for (int i = 0; i < Q; i++)
        {
            feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        }
    }
    
    StoreSimulationData3D(texelX, texelY, texelZ, feq, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, float4(1., 0., 1., 1.));
    }
}

void ReverseF(in out float f[Q])
{
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float temp = f[i];
        f[i] = f[Q - i];
        f[Q - i] = temp;
    }
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Streaming3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{
    /*
    
    1 2 3 
    4 0 5
    6 7 8
    
    */
    int texelX = (int) DispatchThreadId.x;
    int texelY = (int) DispatchThreadId.y;
    uint texelZ = (int) DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    int3 c[Q] =
    {
        int3(0, 0, 0),
        int3(-1, -1, 0),
        int3(0, -1, 0),
        int3(1, -1, 0),
        int3(-1, 0, 0),
        int3(0, -1, 1),
        int3(-1, 0, 1),
        int3(0, 0, 1),
        int3(1, 0, 1),
        int3(0, 1, 1),
        int3(0, -1, -1),
        int3(-1, 0, -1),
        int3(0, 0, -1),
        int3(1, 0, -1),
        int3(0, 1, -1),
        int3(1, 0, 0),
        int3(-1, 1, 0),
        int3(0, 1, 0),
        int3(1, 1, 0),
    };
    int halfQ = (Q + 1) / 2;
    for (int i = 1; i < halfQ; i++)
    {
        float f_1, f_2;
        if (texelX + c[i].x < 0 || texelX + c[i].x > 255)
        {
            continue;
        }
        if (texelY + c[i].y < 0 || texelY + c[i].y > 255)
        {
            continue;
        }
        if (texelZ + c[i].z < 0 || texelZ + c[i].z > 255)
        {
            continue;
        }
        ReadSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_1);
        ReadSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_2);
        StoreSimulationDataIndex3D(texelX, texelY, texelZ, Q - i, f_2);
        StoreSimulationDataIndex3D(texelX + c[i].x, texelY + c[i].y, texelZ + c[i].z, i, f_1);
    }
}

bool IsNaN(float x)
{
    return !(x < 0.f || x > 0.f || x == 0.f);
}

void GetVelocityAndDensity(in float f[Q], out float3 u, out float p)
{
    float3 c[Q] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    p = 0.;
    u = float3(0., 0., 0.);
    for (int i = 0; i < Q; i++)
    {
        p += f[i];
        u += c[i] * f[i];
    }
    u = u / p;
}

[numthreads(BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z)]
void LBM_Collision3D(
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 tid : SV_GroupThreadID,
	uint GroupIndex : SV_GroupIndex,
	uint3 GroupID : SV_GroupID)
{    
    uint texelX = DispatchThreadId.x;
    uint texelY = DispatchThreadId.y;
    uint texelZ = DispatchThreadId.z;
    if (texelX > SimDimension.x - 1 || texelY > SimDimension.y - 1 || texelZ > SimDimension.z - 1)
    {
        return;
    }
    
    // LBM constants
    float3 c[Q] =
    {
        float3(0., 0., 0.),
        float3(-1., -1., 0.),
        float3(0., -1., 0.),
        float3(1., -1., 0.),
        float3(-1., 0., 0.),
        float3(0., -1., 1.),
        float3(-1., 0., 1.),
        float3(0., 0., 1.),
        float3(1., 0., 1.),
        float3(0., 1., 1.),
        float3(0., -1., -1.),
        float3(-1., 0., -1.),
        float3(0., 0., -1.),
        float3(1., 0., -1.),
        float3(0., 1., -1.),
        float3(1., 0., 0.),
        float3(-1., 1., 0.),
        float3(0., 1., 0.),
        float3(1., 1., 0.),
    };
    
    float w[Q] =
    {
        1. / 3., // [0]
        1. / 36., // [1 - 4]
        2. / 36.,
        1. / 36.,
        2. / 36.,
        1. / 36., // [5 - 9]
        1. / 36.,
        2. / 36.,
        1. / 36.,
        1. / 36.,
        1. / 36., // [10 - 14]
        1. / 36.,
        2. / 36.,
        1. / 36.,
        1. / 36.,
        2. / 36., // [15 - 18]
        1. / 36.,
        2. / 36.,
        1. / 36.
    };
    
    // lbm distribution functions
    float f[Q];
    int boundary = 0;
    float4 debugValue = float4(0., 0., 0., 1.);
    
    ReadSimulationData3D(texelX, texelY, texelZ, f, boundary);
    float f_fake = -1. * (texelX + SimDimension.x * texelY);
    if (boundary == 1)
    {
        debugValue = float4(1., 0., 0., 1.);
        for (int i = 0; i < Q; i++)
        {
            f[i] = f_fake;
        }
    }
    if (boundary == 2)
    {
        debugValue = float4(0., 1., 0., 1.);
        float3 u = float3(InitialVelocity, 0., 0.);
        float p = InitialDensity;
        for (int i = 0; i < Q; i++)
        {
            f[i] = w[i] * p * (1. + 3. * dot(c[i], u) + 4.5 * pow(dot(c[i], u), 2.) - 1.5 * dot(u, u));
        }
    }
    uint3 offset = uint3(-1, 0, 0);
    if (boundary == 3 && texelY == 1)
    {
        offset = uint3(-1, 1, 0);
    }
    else if (boundary == 3 && texelY == SimDimension.y - 2)
    {
        offset = uint3(-1, -1, 0);
    }
    else if (boundary == 3 && texelZ == 1)
    {
        offset = uint3(-1, 0, 1);
    }
    else if (boundary == 3 && texelZ == SimDimension.z - 2)
    {
        offset = uint3(-1, 0, -1);
    }
    if (boundary == 3)
    {
        debugValue = float4(1., 1., 1., 1.);
        float boundary_left;
        ReadSimulationData3D(texelX + offset.x, texelY + offset.y, texelZ + offset.z, f, boundary_left);
    }
    if (boundary >= 1) // no simulation inside solid 
    {
        ReverseF(f);
        StoreSimulationData3D(texelX, texelY, texelZ, f, boundary);
        
        if (texelZ == DEBUG_TEXTURE_SLICE)
        {
            StoreDebugTexture2D(texelX, texelY, debugValue);
        }
        return;
    }
    
    
    float p = 0.;
    float3 u = float3(0., 0., 0.);
    
    // boundary treatment
    // bounce back
    for (int i = 1; i < Q; i++)
    {
        if (f[i] < 0. && f[Q - i] < 0.)
        {
            // linear interpolated bounce-back, Tao et al 2018
            // f_streamed[i] stores negtive value of distance from interior grid point to boundary
            /*float q = 1. + f_streamed[i] / length(c[i]);
            float p_b_prev = 0.;
            float3 u_b_prev = 0.;
            GetVelocityAndDensity(f, u_b_prev, p_b_prev);
            float feq_b = GetEquilibrium(float3(0., 0., 0.), p_b_prev, c[i], w[i]); // assume solid boundary velocity is 0
            float feq_b_prev = GetEquilibrium(u_b_prev, p_b_prev, c[i], w[i]);
            float f_b = 1. / (1. + q) * (feq_b + f[i] - feq_b_prev)
                + q / (1. + q) * f[19 - i].x;
            f_streamed[i] = f_b;*/
            
            // classical bounce-back
            f[i] = 0.;
            f[Q - i] = 0.;
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
        else if (f[i] < 0.)
        {
            f[i] = f[Q - i];
            debugValue.xyz = float3(0.5, 0.5, 0.5);
        }
    }
    GetVelocityAndDensity(f, u, p);
    debugValue.xyz = float3(length(u), 0., p);
    if (IsNaN(p) || IsNaN(length(u)) )
    {
        debugValue.xyz = float3(0., 1., 0.);
    }
    if (p == 0. || length(u) == 0.)
    {
        debugValue.xyz = float3(0., 0., 1.);
    }
    
    // collision
    float cs = 1. / sqrt(3.);
    float feq[Q];
    for (int i = 0; i < Q; i++)
    {
        feq[i] = GetEquilibrium(u, p, c[i], w[i]);
        f[i] = f[i] - (f[i] - feq[i]) / RelaxationFactor; // relaxation time tau = 0.1
    }
    ReverseF(f);
    StoreSimulationData3D(texelX, texelY, texelZ, f, boundary);
    if (texelZ == DEBUG_TEXTURE_SLICE)
    {
        StoreDebugTexture2D(texelX, texelY, debugValue);
    }
    StoreDebugTexture3D(texelX, texelY, texelZ, debugValue);
}
