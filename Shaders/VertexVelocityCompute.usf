// VertexVelocityCompute.usf
#include "/Engine/Public/Platform.ush"

// Input buffers
StructuredBuffer<float> TriangleVerts;
RWStructuredBuffer<float> VertexVelocities;

// Parameters
float4x4 LocalToWorld;
float DeltaTime;
uint VertexCount;

void LoadVertexPosition(in uint vertex, out float3 pos)
{
	vertex = clamp(vertex, 0, VertexCount - 1);
	pos.x = TriangleVerts[vertex * 3 + 0];
	pos.y = TriangleVerts[vertex * 3 + 1];
	pos.z = TriangleVerts[vertex * 3 + 2];
}

[numthreads(64, 1, 1)]
void CalculateVertexVelocity(uint3 DTid : SV_DispatchThreadID)
{
	if (DTid.x >= VertexCount) { return; }

    float deltaTime = max(0.01f, DeltaTime);

	// Load vertex position in local space
	float3 localPos;
	LoadVertexPosition(DTid.x, localPos);

	// Transform to world space
	float4 worldPos = mul(LocalToWorld, float4(localPos, 1.0));

	// Calculate velocity based on transformation
	// For rigid body motion, velocity = (currentPos - previousPos) / deltaTime
	// Since we're using LocalToWorld, we can calculate velocity from the transformation matrix
	// The velocity is the derivative of position with respect to time
	// For a rigid body: v = (M * p - M_prev * p) / dt
	// Simplified: v = (dM/dt * p) where dM/dt is approximated by the transformation change
	
	// If you have previous frame's LocalToWorld, you'd do:
	// float4 prevWorldPos = mul(PreviousLocalToWorld, float4(localPos, 1.0));
	// float3 velocity = (worldPos.xyz - prevWorldPos.xyz) / deltaTime;
	
	// For now, assuming you'll pass previous positions or calculate based on mesh motion
	// This is a placeholder - you'll need to adapt based on your specific velocity calculation needs
	float3 velocity = float3(0.0, 0.0, 0.0);
	
	// Write velocity (3 floats per vertex)
	VertexVelocities[DTid.x * 3 + 0] = velocity.x;
	VertexVelocities[DTid.x * 3 + 1] = velocity.y;
	VertexVelocities[DTid.x * 3 + 2] = velocity.z;
}
